{
  "folders": [
    {
      "name": "Android-初期构建",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "java",
      "id": "5uOcX0Wd",
      "createdAt": 1666083009043,
      "updatedAt": 1666083939117,
      "index": 0
    },
    {
      "name": "Android-功能模块",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "java",
      "id": "9oVt2TRO",
      "createdAt": 1666083157594,
      "updatedAt": 1666094159165,
      "index": 1
    },
    {
      "name": "Android-代码片段",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "java",
      "id": "XVnzjXNQ",
      "createdAt": 1666083117327,
      "updatedAt": 1666093743543,
      "index": 2
    },
    {
      "name": "Android-自定义控件",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "java",
      "id": "1NX5tDl1",
      "createdAt": 1659359284713,
      "updatedAt": 1666085868106,
      "index": 3
    },
    {
      "name": "Java",
      "parentId": null,
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "java",
      "id": "t6KJDGSQ",
      "createdAt": 1666084050580,
      "updatedAt": 1666084097895,
      "index": 4
    }
  ],
  "snippets": [
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "9oVt2TRO",
      "tagsIds": [],
      "description": "socket 客户端和服务端的实现方式，在两个app中分别使用后，可实现互相通信的效果",
      "name": "Socket",
      "content": [
        {
          "label": "SocketClient",
          "language": "java",
          "value": "import android.os.Handler;\r\nimport android.os.Looper;\r\nimport android.util.Log;\r\n\r\nimport java.io.DataOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.net.ConnectException;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.NoRouteToHostException;\r\nimport java.net.Socket;\r\nimport java.net.SocketTimeoutException;\r\nimport java.util.Arrays;\r\nimport java.util.Timer;\r\nimport java.util.TimerTask;\r\n\r\n/**\r\n * 一个socket client，设计成单例的形式，可进行收发消息，会定时向server端发送心跳包\r\n * <p>\r\n * <p>\r\n * 初始化SocketThread：\r\n * <blockquote>\r\n * SocketClient.INSTANCE.initSocket(ip, port)\r\n * </blockquote>\r\n * 发送消息：\r\n * <blockquote>\r\n * SocketClient.INSTANCE.sendData(Msg)\r\n * </blockquote>\r\n * 连接成功的回调：\r\n * <blockquote>\r\n * SocketClient.INSTANCE.setOnSocketStatusListener(() -> {...})\r\n * </blockquote>\r\n * 接收到消息的回调：\r\n * <blockquote>\r\n * SocketClient.INSTANCE.setOnReceiveDataListener(message -> {...})\r\n * </blockquote>\r\n */\r\n//TODO: 注意增加网络权限\r\npublic enum SocketClient {\r\n    INSTANCE; //通过枚举的方式创建单例\r\n    private static final String TAG = \"SocketClient\";\r\n\r\n    //字节流数据\r\n    public static final byte[] HEARTBEAT = {0x01, 0x00, 0x00, 0x00};\r\n    public static final byte[] BYTE_MSG_1 = {0x02, 0x00, 0x00, 0x00};\r\n    public static final byte[] BYTE_MSG_2 = {0x03, 0x00, 0x00, 0x00};\r\n\r\n    //字符流数据\r\n    //....\r\n\r\n    private String ip;\r\n    private int port;\r\n    private Socket socket;\r\n    private Thread connectThread;\r\n\r\n    private final int heartCycle = 10; //心跳周期(s)\r\n    private OutputStream outputStream; //发送输出流\r\n    private final boolean isReConnect = true; //默认重连\r\n    private Timer timer; //倒计时Timer发送心跳包\r\n    private TimerTask task;\r\n    private final Handler handler = new Handler(Looper.getMainLooper());\r\n\r\n\r\n    // ========================== callback =========================== //\r\n    public interface OnSocketStatusListener {\r\n        /**\r\n         * 连接成功的回调\r\n         */\r\n        void onConnectSuccess();\r\n    }\r\n\r\n    public interface OnReceiveDataListener {\r\n        /**\r\n         * 收到消息的回调\r\n         */\r\n        void onReceiveData(byte[] message);\r\n    }\r\n\r\n    public OnSocketStatusListener onSocketStatusListener;\r\n    public OnReceiveDataListener onReceiveDataListener;\r\n\r\n    public void setOnSocketStatusListener(OnSocketStatusListener onSocketStatusListener) {\r\n        this.onSocketStatusListener = onSocketStatusListener;\r\n    }\r\n\r\n    public void setOnReceiveDataListener(OnReceiveDataListener onReceiveDataListener) {\r\n        this.onReceiveDataListener = onReceiveDataListener;\r\n    }\r\n\r\n\r\n    // ========================== function =========================== //\r\n\r\n    /**\r\n     * 初始化socket\r\n     *\r\n     * @param ip   ip地址，如果使用回环地址，则应是127.0.0.1\r\n     * @param port 自定义通信端口，最大至65535\r\n     */\r\n    public void initSocket(final String ip, final int port) {\r\n        this.ip = ip;\r\n        this.port = port;\r\n\r\n        if (socket == null && connectThread == null) {\r\n            connectThread = new Thread(() -> {\r\n                socket = new Socket();\r\n                try {\r\n                    socket.connect(new InetSocketAddress(ip, port), 60_000); //超时时间为2秒\r\n                    if (socket.isConnected()) {\r\n                        Log.d(TAG, \"client:服务连接成功\");\r\n                        new ReadThread().start(); //开启读写线程\r\n                        if (onSocketStatusListener != null)\r\n                            onSocketStatusListener.onConnectSuccess(); //连接成功的回调\r\n                        Thread.sleep(5_000); //5s后发送心跳包\r\n                        sendHeartbeat();\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                    if (e instanceof SocketTimeoutException) {\r\n                        Log.e(TAG, \"client:连接超时，正在重连\");\r\n                        releaseSocket();\r\n                    } else if (e instanceof NoRouteToHostException) {\r\n                        Log.e(TAG, \"client:该地址不存在，请检查\");\r\n                    } else if (e instanceof ConnectException) {\r\n                        Log.e(TAG, \"client:连接异常或被拒绝，请检查\");\r\n                    }\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            });\r\n            connectThread.start(); //启动连接线程\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 发送数据\r\n     *\r\n     * @param msg 一个byte数组\r\n     */\r\n    public void sendMessage(byte[] msg) {\r\n        if (socket != null && socket.isConnected()) {\r\n            /*发送指令*/\r\n            new Thread(() -> {\r\n                try {\r\n                    Log.i(TAG, \"client:发送自定义指令:\" + Arrays.toString(msg));\r\n                    //字节流\r\n                    DataOutputStream out = new DataOutputStream(socket.getOutputStream());\r\n                    out.write(msg);\r\n                    out.flush();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }).start();\r\n        } else {\r\n            Log.e(TAG, \"client:socket连接错误,请重试\");\r\n        }\r\n    }\r\n\r\n\r\n    // ========================== private function =========================== //\r\n\r\n    /**\r\n     * 读线程\r\n     */\r\n    private class ReadThread extends Thread {\r\n        @Override\r\n        public void run() {\r\n            super.run();\r\n            while (socket != null && socket.isConnected()) {\r\n                try (InputStream in = socket.getInputStream()) {\r\n                    //字节流\r\n                    byte[] buff = new byte[HEARTBEAT.length];\r\n                    while ((in.read(buff)) != -1) {\r\n                        Log.d(TAG, \"client:客户端收到的字节流: \" + Arrays.toString(buff));\r\n                        //接收到数据，切换主线程，显示数据\r\n                        handler.post(() -> {\r\n                            if (onReceiveDataListener != null) {\r\n                                onReceiveDataListener.onReceiveData(buff);\r\n                            }\r\n                        });\r\n                    }\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                    Log.e(TAG, \"client:接收总控数据异常\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 定时发送心跳数据\r\n     */\r\n    private void sendHeartbeat() {\r\n        if (timer == null) {\r\n            timer = new Timer();\r\n        }\r\n        if (task == null) {\r\n            task = new TimerTask() {\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        Log.i(TAG, \"client:发送心跳包:\" + Arrays.toString(HEARTBEAT));\r\n                        //字节流\r\n                        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\r\n                        out.write(HEARTBEAT);\r\n                        out.flush();\r\n                    } catch (Exception e) {\r\n                        releaseSocket();\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        timer.schedule(task, 0, 1000 * heartCycle);\r\n    }\r\n\r\n    /**\r\n     * 释放资源\r\n     */\r\n    private void releaseSocket() {\r\n        if (task != null) {\r\n            task.cancel();\r\n            task = null;\r\n        }\r\n        if (timer != null) {\r\n            timer.purge();\r\n            timer.cancel();\r\n            timer = null;\r\n        }\r\n        if (outputStream != null) {\r\n            try {\r\n                outputStream.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            outputStream = null;\r\n        }\r\n        if (socket != null) {\r\n            try {\r\n                socket.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            socket = null;\r\n        }\r\n        if (connectThread != null) {\r\n            connectThread = null;\r\n        }\r\n        /*重新初始化socket*/\r\n        if (isReConnect) {\r\n            Log.e(TAG, \"client:连接断开，正在重连\");\r\n            initSocket(ip, port);\r\n        }\r\n    }\r\n\r\n}"
        },
        {
          "label": "SocketServer",
          "language": "java",
          "value": "import android.util.Log;\r\n\r\nimport java.io.DataOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.net.InetAddress;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * 一个socket server，设计成单例的形式，可进行收发消息\r\n * <p>\r\n * <p>\r\n * 初始化SocketServer：\r\n * <blockquote>\r\n * SocketServer.INSTANCE.initSocketServer(port);\r\n * </blockquote>\r\n * 发送消息：\r\n * <blockquote>\r\n * SocketServer.INSTANCE.sendMessage(Msg)\r\n * </blockquote>\r\n */\r\n//TODO: 注意增加网络权限\r\npublic enum SocketServer {\r\n    INSTANCE; //通过枚举的方式创建单例\r\n    private static final String TAG = \"SocketServer\";\r\n\r\n    //字节流数据\r\n    public static final byte[] HEARTBEAT = {0x01, 0x00, 0x00, 0x00};\r\n    public static final byte[] BYTE_MSG_1 = {0x02, 0x00, 0x00, 0x00};\r\n    public static final byte[] BYTE_MSG_2 = {0x03, 0x00, 0x00, 0x00};\r\n\r\n    private Socket socket;\r\n\r\n\r\n    // ========================== function =========================== //\r\n\r\n    /**\r\n     * 初始化socketServer，监听端口，等待客户端连接\r\n     *\r\n     * @param port 自定义通信端口，最大至65535\r\n     */\r\n    public void initSocketServer(final int port) {\r\n        new Thread(() -> {\r\n            try {\r\n                ServerSocket serverSocket = new ServerSocket(port); //创建ServerSocket\r\n                Log.d(TAG, \"server:开启服务器\");\r\n                while (true) {\r\n                    Log.d(TAG, \"server:等待客户端连接\");\r\n                    socket = serverSocket.accept(); //等待客户端连接\r\n                    if (serverSocket.isBound()) {\r\n                        Log.d(TAG, \"server:得到客户端连接：\" + socket);\r\n                        new ReadThread().start(); //开启读写线程\r\n                    }\r\n                }\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }).start();\r\n    }\r\n\r\n\r\n    /**\r\n     * 通过socket来给客户端发送消息\r\n     *\r\n     * @param msg 字节数组\r\n     */\r\n    public void sendMessage(byte[] msg) {\r\n        if (socket != null) {\r\n            new Thread(() -> {\r\n                try {\r\n                    Log.i(TAG, \"server:发送自定义指令:\" + Arrays.toString(msg));\r\n                    //字节流\r\n                    DataOutputStream out = new DataOutputStream(socket.getOutputStream());\r\n                    out.write(msg);\r\n                    out.flush();\r\n                    //字符流\r\n//                    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), true);\r\n//                    out.println(msg);\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }).start();\r\n        } else {\r\n            Log.d(TAG, \"server:没有客户端连接，无法发送消息\");\r\n        }\r\n    }\r\n\r\n\r\n    // ========================== private function =========================== //\r\n\r\n    /**\r\n     * 读线程\r\n     */\r\n    private class ReadThread extends Thread {\r\n        @Override\r\n        public void run() {\r\n            super.run();\r\n            while (socket != null && socket.isConnected()) {\r\n                try (InputStream in = socket.getInputStream()) {\r\n                    //字节流\r\n                    byte[] buff = new byte[HEARTBEAT.length];\r\n                    while ((in.read(buff)) != -1) {\r\n                        Log.d(TAG, \"server:收到的字节流: \" + Arrays.toString(buff));\r\n                        //此处可增加回调...\r\n                    }\r\n                    //字符流\r\n//                    BufferedReader inBuff = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\r\n//                    String line;\r\n//                    while ((line = inBuff.readLine()) != null) {// 读取数据\r\n//                        Log.d(TAG, \"server:收到的字符流：\" + line);\r\n//                    }\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n"
        }
      ],
      "id": "wdwc3YPP",
      "createdAt": 1659359309378,
      "updatedAt": 1666085256036
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "5uOcX0Wd",
      "tagsIds": [],
      "description": "通用RecyclerView适配器",
      "name": "RecyclerView Adapter",
      "content": [
        {
          "label": "CommonBaseAdapter",
          "language": "java",
          "value": "import android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport androidx.annotation.NonNull;\nimport androidx.recyclerview.widget.RecyclerView;\n\nimport java.util.List;\n\n/**\n * 通用RecyclerView适配器\n * <p>\n * <p>\n * 1. 在新的类中直接实现其中的接口即可使用：\n * <blockquote>\n * implements CommonBaseAdapter...\n * </blockquote>\n * 2. 使用匿名内部类的形式创建：\n * <blockquote>\n * CommonBaseAdapter<mType> Adapter = new CommonBaseAdapter<>(list,\n *      new CommonBaseAdapter.OnBindDataInterface<mType>() {...}\n * </blockquote>\n */\npublic class CommonBaseAdapter<T> extends RecyclerView.Adapter<BaseViewHolder> {\n\n    private final List<T> mData;\n    private final OnBindDataInterface<T> mOnBindDataInterface;\n    private OnMultiTypeBindDataInterface<T> mOnMultiTypeBindDataInterface;\n    private ItemOnClickInterface itemOnClickInterface;\n\n\n    //单样式列表初始化方法\n    public CommonBaseAdapter(List<T> data, OnBindDataInterface<T> bindInterface) {\n        mData = data;\n        mOnBindDataInterface = bindInterface;\n    }\n\n    //多样式列表初始化方法\n    public CommonBaseAdapter(List<T> data, OnMultiTypeBindDataInterface<T> bindInterface) {\n        mData = data;\n        mOnMultiTypeBindDataInterface = bindInterface;\n        mOnBindDataInterface = bindInterface;\n    }\n\n    //itemOnClickInterface初始化\n    public void setItemOnClickInterface(ItemOnClickInterface itemOnClickInterface) {\n        this.itemOnClickInterface = itemOnClickInterface;\n    }\n\n\n    @NonNull\n    @Override\n    public BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View view = LayoutInflater\n                .from(parent.getContext())\n                .inflate(mOnBindDataInterface.getItemLayoutId(viewType), parent, false);\n        return new BaseViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(@NonNull BaseViewHolder holder, int position) {\n        mOnBindDataInterface.onBindData(mData.get(position), holder, getItemViewType(position),\n                itemOnClickInterface);\n    }\n\n    @Override\n    public int getItemCount() {\n        return this.mData.size();\n    }\n\n    @Override\n    public int getItemViewType(int position) {\n        if (mOnMultiTypeBindDataInterface != null) {\n            return mOnMultiTypeBindDataInterface.getItemViewType(position);\n        }\n        return 0;\n    }\n\n\n    //单样式item绑定数据的接口，包含一个 布局绑定函数 和 布局中控件的绑定函数\n    public interface OnBindDataInterface<T> {\n        /**\n         * 绑定列表元素的item页面(R.layout.xxx)\n         *\n         * @param viewType\n         * @return\n         */\n        int getItemLayoutId(int viewType);\n\n        /**\n         * 绑定数据(R.id.xxx)，最后一个type参数是多类型item使用的\n         *\n         * @param item   item.get()\n         * @param holder holder.setText(R.id.xxx, \"a string\")\n         * @param type   default 0\n         */\n        void onBindData(T item, BaseViewHolder holder, int type, ItemOnClickInterface itemOnClickInterface);\n    }\n\n    // 多类型item的支持，例如包含head的列表\n    public interface OnMultiTypeBindDataInterface<T> extends OnBindDataInterface<T> {\n        /**\n         * 返回item类型，针对不同的item类型使用不同的布局元素\n         *\n         * @param position switch(case 0, case 1, case 2...)\n         * @return\n         */\n        int getItemViewType(int position);\n    }\n\n    // item的回调接口，当item被点击时，能在其他类中获得相关内容并修改item\n    public interface ItemOnClickInterface {\n        /**\n         * @param position 被点击的item下标\n         */\n        void onItemClick(int position);\n    }\n\n}"
        },
        {
          "label": "BaseViewHolder",
          "language": "java",
          "value": "import android.util.SparseArray;\r\nimport android.view.View;\r\nimport android.widget.ImageView;\r\nimport android.widget.TextView;\r\n\r\nimport androidx.recyclerview.widget.RecyclerView;\r\n\r\nimport com.bumptech.glide.Glide;\r\n\r\n/**\r\n * 通用的ViewHolder，与CommonBaseAdapter配套使用\r\n */\r\npublic class BaseViewHolder extends RecyclerView.ViewHolder {\r\n\r\n    private final SparseArray<View> mViews;\r\n\r\n    public BaseViewHolder(View itemView) {\r\n        super(itemView);\r\n        mViews = new SparseArray<>();\r\n    }\r\n\r\n    /**\r\n     * 通过viewId获取控件\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @return\r\n     */\r\n    public <T extends View> T getSubView(int viewId) {\r\n        View view = mViews.get(viewId);\r\n        if (view == null) {\r\n            view = itemView.findViewById(viewId);\r\n            mViews.put(viewId, view);\r\n        }\r\n        return (T) view;\r\n    }\r\n\r\n    /**\r\n     * 点击事件\r\n     *\r\n     * @param viewId   R.id.xxx\r\n     * @param listener\r\n     */\r\n    public void setOnClickListener(int viewId, View.OnClickListener listener) {\r\n        View view = getSubView(viewId);\r\n        view.setOnClickListener(listener);\r\n    }\r\n\r\n    /**\r\n     * 设置TextView内容\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @param text   a string\r\n     */\r\n    public void setText(int viewId, String text) {\r\n        TextView tv = getSubView(viewId);\r\n        if (tv != null) {\r\n            tv.setText(text);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置ImageView背景图片\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @param resId  R.drawable.xxx\r\n     */\r\n    public void setImage(int viewId, int resId) {\r\n        ImageView iv = getSubView(viewId);\r\n        if (iv != null) {\r\n            iv.setBackgroundResource(resId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置ImageView大尺寸图片\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @param resId  R.drawable.xxx\r\n     */\r\n    public void setBigImage(int viewId, int resId) {\r\n        ImageView iv = getSubView(viewId);\r\n        if (iv != null) {\r\n            Glide.with(iv.getContext()).load(resId).into(iv);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置网络资源图片\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @param resUrl http:\\\\....\\\r\n     */\r\n\tpublic void setNetworkImage(int viewId, String resUrl) {\r\n        ImageView iv = getSubView(viewId);\r\n        if (iv != null) {\r\n//            RequestOptions options = new RequestOptions()\r\n//                    .placeholder(R.drawable.xxx) //加载之前显示的图片\r\n//                    .fallback(R.drawable.xxx) //url为空显示的图片\r\n//                    .error(R.drawable.xxx); //加载失败显示的图片\r\n//            Glide.with(iv.getContext())\r\n//\t\t\t\t\t  .load(resUrl)\r\n//                    .centerInside() //对齐方式\r\n//\t\t\t\t\t  .override(width, height) //图片长宽\r\n//\t\t\t\t\t  .apply(options)\r\n//\t\t\t\t\t  .into(iv);\r\n        }\r\n    }\r\n\r\n}\r\n"
        }
      ],
      "id": "AUStwG-e",
      "createdAt": 1659359351474,
      "updatedAt": 1683874677877
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "XVnzjXNQ",
      "tagsIds": [],
      "description": "初始化单例",
      "name": "getInstance",
      "content": [
        {
          "label": "Instance",
          "language": "java",
          "value": "private static CLASS_NAME mInstance;\r\n\r\n/**\r\n * 初始化单例\r\n *\r\n * @return LogcatManager.class\r\n */\r\npublic static synchronized CLASS_NAME getInstance() {\r\n    synchronized (CLASS_NAME.class) {\r\n        if (mInstance == null) {\r\n            mInstance = new CLASS_NAME();\r\n        }\r\n    }\r\n    return mInstance;\r\n}"
        }
      ],
      "id": "HsJpzGes",
      "createdAt": 1659367449128,
      "updatedAt": 1666094128746
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "1NX5tDl1",
      "tagsIds": [],
      "description": "竖直的seekbar，xml文件中直接使用此自定义控件",
      "name": "VerticalSeekBar",
      "content": [
        {
          "label": "VerticalSeekBar",
          "language": "java",
          "value": "import android.content.Context;\r\nimport android.graphics.Canvas;\r\nimport android.util.AttributeSet;\r\nimport android.view.MotionEvent;\r\n\r\n/**\r\n * 竖直的seekbar，xml文件中直接使用此自定义控件\r\n */\r\npublic class VerticalSeekBar extends androidx.appcompat.widget.AppCompatSeekBar {\r\n    private OnSeekBarChangeListener mOnSeekBarChangeListener;\r\n\r\n    public VerticalSeekBar(Context context) {\r\n        super(context);\r\n    }\r\n\r\n    public VerticalSeekBar(Context context, AttributeSet attrs) {\r\n        super(context, attrs);\r\n    }\r\n\r\n    public VerticalSeekBar(Context context, AttributeSet attrs, int defStyleAttr) {\r\n        super(context, attrs, defStyleAttr);\r\n    }\r\n\r\n    public void setOnSeekBarChangeListener(OnSeekBarChangeListener l) {\r\n        mOnSeekBarChangeListener = l;\r\n    }\r\n\r\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\r\n        super.onSizeChanged(h, w, oldh, oldw);\r\n    }\r\n\r\n    @Override\r\n    protected synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\r\n        super.onMeasure(heightMeasureSpec, widthMeasureSpec);\r\n        setMeasuredDimension(getMeasuredHeight(), getMeasuredWidth());\r\n    }\r\n\r\n    protected void onDraw(Canvas c) {\r\n        c.rotate(-90); //旋转画布，实现竖直seekbar\r\n        c.translate(-getHeight(), 0);\r\n        super.onDraw(c);\r\n    }\r\n\r\n    void onProgressChanged(int progress) {\r\n        if (mOnSeekBarChangeListener != null) {\r\n            mOnSeekBarChangeListener.onProgressChanged(this, progress, true);\r\n        }\r\n    }\r\n\r\n    void onStartTrackingTouch() {\r\n        if (mOnSeekBarChangeListener != null) {\r\n            mOnSeekBarChangeListener.onStartTrackingTouch(this);\r\n        }\r\n    }\r\n\r\n    void onStopTrackingTouch() {\r\n        if (mOnSeekBarChangeListener != null) {\r\n            mOnSeekBarChangeListener.onStopTrackingTouch(this);\r\n        }\r\n    }\r\n\r\n    private void attemptClaimDrag() {\r\n        if (getParent() != null) {\r\n            getParent().requestDisallowInterceptTouchEvent(true);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean onTouchEvent(MotionEvent event) {\r\n        if (!isEnabled()) {\r\n            return false;\r\n        }\r\n        switch (event.getAction()) {\r\n            case MotionEvent.ACTION_DOWN:\r\n                setPressed(true);\r\n                onStartTrackingTouch();\r\n                break;\r\n            case MotionEvent.ACTION_MOVE:\r\n                attemptClaimDrag();\r\n                int len = getMax() - getMin();\r\n                int num = (getMax() - (int) (len * event.getY() / getHeight())); //根据触摸调整进度条\r\n                num = (num > getMax()) ? getMax() : num; //num的值最大为getMax()\r\n                num = (num < getMin()) ? getMin() : num; //num的值最小为getMin()\r\n                setProgress(num);\r\n                onProgressChanged(num);\r\n                break;\r\n            case MotionEvent.ACTION_UP:\r\n            case MotionEvent.ACTION_CANCEL:\r\n                onStopTrackingTouch();\r\n                setPressed(false);\r\n                break;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"
        }
      ],
      "id": "BszPKY2C",
      "createdAt": 1659367456523,
      "updatedAt": 1669290154292
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "9oVt2TRO",
      "tagsIds": [],
      "description": "捕获程序漏掉的崩溃异常，并重启应用或服务",
      "name": "UnCeHandler",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "import android.app.AlarmManager;\r\nimport android.app.Application;\r\nimport android.app.PendingIntent;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.os.Build;\r\nimport android.util.Log;\r\n\r\n/**\r\n * 捕获程序漏掉的崩溃异常，并重启应用或服务\r\n * <p>\r\n * <p>\r\n * 在application中使用如下方式调用：\r\n * <p>\r\n * <p>\r\n * 重启Activity（android 10+ 需要提供悬浮窗权限）:\r\n * <blockquote><code>\r\n * Thread.setDefaultUncaughtExceptionHandler(new UnCeHandler(this, Activity.class, UnCeHandler.TYPE_ACTIVITY));\r\n * </code></blockquote>\r\n * <p>\r\n * <p>\r\n * 单独重启Service:\r\n * <blockquote><code>\r\n * Thread.setDefaultUncaughtExceptionHandler(new UnCeHandler(this, Service.class, UnCeHandler.TYPE_SERVICE));\r\n * </code></blockquote>\r\n */\r\npublic class UnCeHandler implements Thread.UncaughtExceptionHandler {\r\n    public static final String TAG = \"UnCeHandler\";\r\n    public static final int TYPE_ACTIVITY = 0x0;\r\n    public static final int TYPE_SERVICE = 0x1;\r\n\r\n    private static final long DELAY_CLOSE_TIME = 2_000; //延迟杀掉应用的时间\r\n    private static final long REBOOT_TIME = 1_000; //重启应用的时间\r\n    private final Thread.UncaughtExceptionHandler mDefaultHandler;\r\n    private final Application application;\r\n    private final Context mContext;\r\n    private final Class<?> cls;\r\n    private final int selectType;\r\n\r\n\r\n    // ===================== init ============================== //\r\n    public UnCeHandler(Application application, Class<?> cls, int type) {\r\n        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();\r\n        this.application = application;\r\n        this.mContext = application.getApplicationContext();\r\n        this.cls = cls;\r\n        this.selectType = type;\r\n    }\r\n\r\n\r\n    // ===================== Override ============================== //\r\n    @Override\r\n    public void uncaughtException(Thread thread, Throwable ex) {\r\n        if (!handleException(ex) && mDefaultHandler != null) {\r\n            //如果用户没有处理则让系统默认的异常处理器来处理\r\n            mDefaultHandler.uncaughtException(thread, ex);\r\n        } else {\r\n            delayClose(); //延迟指定时间\r\n\r\n            Intent intent = new Intent(mContext, cls);\r\n            PendingIntent restartIntent;\r\n            AlarmManager mgr;\r\n            switch (selectType) {\r\n                //重启service服务\r\n                case TYPE_SERVICE:\r\n                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n                        /* PendingIntent.getForegroundService(context, requestCode, intent, flags)\r\n                         *\r\n                         * 第一个参数：连接上下文的context\r\n                         * 第二个参数：是对PendingIntent的描述，请求值不同Intent就不同\r\n                         * 第三个参数：是一个Intent对象，包含跳转目标\r\n                         * 第四个参数有4种状态：\r\n                         *      FLAG_CANCEL_CURRENT: 如果有多个requestCode，则使用最新的PendingIntent对象\r\n                         *      FLAG_NO_CREATE: 如果有相同的PendingIntent存在，直接使用，否则返回null，不会自动创建新的\r\n                         *      FLAG_ONE_SHOT: 该PendingIntent只作用一次，触发后会销毁，再次触发会返回SendIntentException\r\n                         *      FLAG_UPDATE_CURRENT: 如果有一个相同的PendingIntent，则更新之前的数据，使旧的和新的数据一致\r\n                         *      常用的为 FLAG_CANCEL_CURRENT 和 FLAG_UPDATE_CURRENT\r\n                         */\r\n                        restartIntent = PendingIntent.getForegroundService(\r\n                                mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\r\n                    } else {\r\n                        restartIntent = PendingIntent.getService(\r\n                                mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\r\n                    }\r\n                    break;\r\n                //重启Activity\r\n                case TYPE_ACTIVITY:\r\n                default:\r\n                    //如果在android 10+上使用，请增加android.permission.SYSTEM_ALERT_WINDOW权限，\r\n                    //否则无法凭空创建出activity\r\n                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\r\n                    restartIntent = PendingIntent.getActivity(\r\n                            mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\r\n                    break;\r\n            }\r\n            mgr = (AlarmManager) application.getSystemService(Context.ALARM_SERVICE);\r\n            mgr.set(AlarmManager.RTC, System.currentTimeMillis() + REBOOT_TIME, restartIntent);\r\n            android.os.Process.killProcess(android.os.Process.myPid());\r\n        }\r\n    }\r\n\r\n\r\n    // ===================== function ============================== //\r\n\r\n    /**\r\n     * 延迟指定时间关闭\r\n     */\r\n    private void delayClose() {\r\n        if (DELAY_CLOSE_TIME > 0) {\r\n            try {\r\n                Thread.sleep(DELAY_CLOSE_TIME);\r\n            } catch (InterruptedException e) {\r\n                Log.e(TAG, \"error: \", e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 自定义错误处理，收集错误信息 发送错误报告等操作均在此完成\r\n     *\r\n     * @param ex\r\n     * @return true:处理了该异常信息，否则返回false\r\n     */\r\n    private boolean handleException(Throwable ex) {\r\n        if (ex == null) {\r\n            return false;\r\n        }\r\n        //TODO：程序退出前会先运行此函数，可以在此处理异常信息\r\n        // (无法做UI类的操作，因为程序已经运行不下去了，自测Toast会无效，但是log.d有用，文件读写是否有用有待测试)\r\n        Log.d(TAG, \"handleException: \" + ex.toString());\r\n        return true;\r\n    }\r\n\r\n}"
        }
      ],
      "id": "lOj7773n",
      "createdAt": 1666083201819,
      "updatedAt": 1685331144222
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "5uOcX0Wd",
      "tagsIds": [],
      "description": "控制Fragment增加、清除、替换等行为",
      "name": "mFragmentManage",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "import androidx.fragment.app.Fragment;\r\nimport androidx.fragment.app.FragmentActivity;\r\nimport androidx.fragment.app.FragmentManager;\r\nimport androidx.fragment.app.FragmentTransaction;\r\n\r\nimport com.example.androiddemoapp.R;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n * 控制Fragment增加、清除、替换等行为\r\n */\r\npublic class mFragmentManage {\r\n\r\n    private final FragmentActivity activity;\r\n    private final FragmentManager fragmentManager;\r\n\r\n    public mFragmentManage(FragmentActivity activity) {\r\n        this.activity = activity;\r\n        fragmentManager = activity.getSupportFragmentManager();\r\n    }\r\n\r\n    \r\n    /**\r\n     * 清空fragmentList的所有Fragment，替换成新的Fragment\r\n     *\r\n     * @param fragment\r\n     */\r\n    public void replaceFragment(Fragment fragment) {\r\n        FragmentManager fragmentManager = activity.getSupportFragmentManager();\r\n        FragmentTransaction transaction = fragmentManager.beginTransaction();\r\n        transaction.replace(R.id.main_fragment_frame, fragment);\r\n        transaction.commit();\r\n    }\r\n\r\n    /**\r\n     * 添加Fragment到FragmentList中\r\n     *\r\n     * @param fragment\r\n     */\r\n    public void addFragment(Fragment fragment) {\r\n        FragmentManager fragmentManager = activity.getSupportFragmentManager();\r\n        FragmentTransaction transaction = fragmentManager.beginTransaction();\r\n        transaction.add(R.id.main_fragment_frame, fragment);\r\n        transaction.commit();\r\n    }\r\n\r\n    /**\r\n     * 移除最上层的Fragment\r\n     */\r\n    public int removeFragment() {\r\n        List<Fragment> fragments = fragmentManager.getFragments();\r\n        if ((fragments != null) && (fragments.size() > 1)) { //当fragment栈有多个fragment时，返回函数才会生效\r\n            FragmentTransaction transaction = fragmentManager.beginTransaction();\r\n            transaction.remove(fragments.get(fragments.size() - 1));\r\n            transaction.commit();\r\n            return fragmentManager.getFragments().size() - 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n}\r\n"
        }
      ],
      "id": "PJU76PYD",
      "createdAt": 1666083255544,
      "updatedAt": 1666083812789
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "5uOcX0Wd",
      "tagsIds": [],
      "description": "基础类",
      "name": "Base",
      "content": [
        {
          "label": "BaseFragment",
          "language": "java",
          "value": "import android.app.Activity;\r\nimport android.content.Context;\r\nimport android.os.Bundle;\r\nimport android.view.LayoutInflater;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.annotation.Nullable;\r\nimport androidx.fragment.app.Fragment;\r\n\r\npublic abstract class BaseFragment extends Fragment {\r\n\r\n    protected Activity mActivity;\r\n    private TopButtonStateInterface topButtonStateInterface;\r\n\r\n    \r\n    /**\r\n     * 获得全局的，防止使用getActivity()为空\r\n     *\r\n     * @param context\r\n     */\r\n    @Override\r\n    public void onAttach(@NonNull Context context) {\r\n        super.onAttach(context);\r\n        this.mActivity = (Activity) context;\r\n\r\n        if (context instanceof TopButtonStateInterface) {\r\n            topButtonStateInterface = (TopButtonStateInterface) context;\r\n        } else {\r\n            throw new RuntimeException(context.toString() + \" must implement TopButtonStateInterface\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container,\r\n                             Bundle savedInstanceState) {\r\n        View view = LayoutInflater.from(mActivity)\r\n                .inflate(getLayoutId(), container, false);\r\n        initView(view, savedInstanceState);\r\n\r\n        //通知activity显示顶部按钮\r\n        topButtonStateInterface.topButtonState();\r\n\r\n        return view;\r\n    }\r\n\r\n    @Override\r\n    public void onActivityCreated(@Nullable Bundle savedInstanceState) {\r\n        super.onActivityCreated(savedInstanceState);\r\n        initData();\r\n    }\r\n\r\n\r\n    /**\r\n     * 该抽象方法就是 onCreateView中需要的layoutID\r\n     *\r\n     * @return\r\n     */\r\n    protected abstract int getLayoutId();\r\n\r\n    /**\r\n     * 该抽象方法就是 初始化view\r\n     *\r\n     * @param view\r\n     * @param savedInstanceState\r\n     */\r\n    protected abstract void initView(View view, Bundle savedInstanceState);\r\n\r\n    /**\r\n     * 执行数据的加载\r\n     */\r\n    protected abstract void initData();\r\n\r\n    /**\r\n     * 顶部主页按钮和返回按钮的回调事件\r\n     * <p>\r\n     * （在activity中通过implements BaseFragment.TopButtonStateInterface使用）\r\n     */\r\n    public interface TopButtonStateInterface {\r\n        void topButtonState();\r\n    }\r\n}\r\n"
        },
        {
          "label": "BaseActivity",
          "language": "java",
          "value": "import android.content.pm.PackageManager;\r\nimport android.os.Bundle;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.core.app.ActivityCompat;\r\nimport androidx.core.content.ContextCompat;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * 包含权限申请的BaseActivity，其他类继承后可实现权限申请\r\n * <p>\r\n * 申请权限时记得在AndroidManifest.xml中增加对应的权限\r\n * <p>\r\n * <p>\r\n * 调用BaseActivity中的权限申请接口：\r\n * <blockquote>\r\n * super.requestRunTimePermission(string, new PermissionListener() {\r\n *     @ Override\r\n *     public void onAllGranted() {\r\n *         //所有权限都通过后会调用此回调\r\n *     }\r\n *\r\n *     @ Override\r\n *     public void onGrantedList(List<String> grantedPermission) {\r\n *         //已通过的权限回调（如果权限全通过，此回调也会被调用一下）\r\n *     }\r\n *\r\n *     @ Override\r\n *     public void onDeniedList(List<String> deniedPermission) {\r\n *         //如果存在不通过的，此回调将会被调用\r\n *     }\r\n * });\r\n * </blockquote>\r\n */\r\npublic abstract class BaseActivity extends AppCompatActivity {\r\n\r\n    private final int REQUEST_CODE = 200;\r\n    private PermissionListener mListener;\r\n\r\n    /**\r\n     * 设置activity对应的layout id\r\n     *\r\n     * @return R.layout.xxx\r\n     */\r\n    protected abstract int setContentViewId();\r\n\r\n    /**\r\n     * 初始化\r\n     */\r\n    protected abstract void myOnCreate();\r\n\r\n\r\n    /**\r\n     * onCreate\r\n     */\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(setContentViewId());\r\n        myOnCreate();\r\n    }\r\n\r\n\r\n    /*====================================== 权限相关 ==========================================*/\r\n\r\n    /**\r\n     * 权限回调接口\r\n     */\r\n    protected interface PermissionListener {\r\n        void onAllGranted(); //授权成功\r\n\r\n        void onGrantedList(List<String> grantedPermission); //授权成功的列表\r\n\r\n        void onDeniedList(List<String> deniedPermission); //授权失败的列表\r\n    }\r\n\r\n    /**\r\n     * 权限申请\r\n     *\r\n     * @param permissions 待申请的权限集合\r\n     * @param listener    申请结果监听事件\r\n     */\r\n    protected void requestRunTimePermission(@NonNull String[] permissions, PermissionListener listener) {\r\n        this.mListener = listener;\r\n        List<String> permissionList = new ArrayList<>();\r\n\r\n        //查找未授权的权限，存入集合\r\n        for (String permission : permissions) {\r\n            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {\r\n                permissionList.add(permission); //未授权，则加入待授权的list中\r\n            }\r\n        }\r\n        if (permissionList.isEmpty()) {\r\n            listener.onAllGranted(); //为空，则已经全部授权\r\n        } else {\r\n            //如果集合不为空，则需要去授权\r\n            //使用ActivityCompat请求权限，然后通过Activity的onRequestPermissionsResult函数获得结果的回调\r\n            ActivityCompat.requestPermissions(this, permissionList.toArray(new String[0]), REQUEST_CODE);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Activity的onRequestPermissionsResult函数，当调用ActivityCompat.requestPermissions申请权限后，此函数\r\n     * 会被回调，用户可在此函数中对回调的结果进行处理。\r\n     *\r\n     * @param requestCode  请求码\r\n     * @param permissions  所有的权限集合\r\n     * @param grantResults 授权结果集合\r\n     */\r\n    @Override\r\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\r\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n        if (requestCode != REQUEST_CODE || grantResults.length <= 0) return;\r\n\r\n        List<String> grantedPermissions = new ArrayList<>(); //用户通过的权限集合\r\n        List<String> deniedPermissions = new ArrayList<>(); //被用户拒绝的权限集合\r\n\r\n        for (int i = 0; i < grantResults.length; i++) {\r\n            if (grantResults[i] == PackageManager.PERMISSION_GRANTED) {\r\n                grantedPermissions.add(permissions[i]); //用户同意的权限\r\n            } else {\r\n                deniedPermissions.add(permissions[i]); //用户拒绝授权的权限\r\n            }\r\n        }\r\n\r\n        //用户拒绝权限为空\r\n        if (deniedPermissions.isEmpty()) {\r\n            mListener.onAllGranted(); //回调所有授权成功的接口\r\n        } else {\r\n            mListener.onDeniedList(deniedPermissions); //回调失败列表的接口\r\n        }\r\n        mListener.onGrantedList(grantedPermissions); //回调成功列表的接口\r\n    }\r\n}"
        }
      ],
      "id": "WNeFVKgd",
      "createdAt": 1666083270445,
      "updatedAt": 1683874705453
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "5uOcX0Wd",
      "tagsIds": [],
      "description": null,
      "name": "CommonBaseAdapter",
      "content": [
        {
          "label": "CommonBaseAdapter",
          "language": "java",
          "value": "import android.app.Activity;\r\nimport android.content.Context;\r\nimport android.os.Bundle;\r\nimport android.view.LayoutInflater;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.annotation.Nullable;\r\nimport androidx.fragment.app.Fragment;\r\n\r\npublic abstract class BaseFragment extends Fragment {\r\n\r\n    protected Activity mActivity;\r\n    private TopButtonStateInterface topButtonStateInterface;\r\n\r\n    \r\n    /**\r\n     * 获得全局的，防止使用getActivity()为空\r\n     *\r\n     * @param context\r\n     */\r\n    @Override\r\n    public void onAttach(@NonNull Context context) {\r\n        super.onAttach(context);\r\n        this.mActivity = (Activity) context;\r\n\r\n        if (context instanceof TopButtonStateInterface) {\r\n            topButtonStateInterface = (TopButtonStateInterface) context;\r\n        } else {\r\n            throw new RuntimeException(context.toString() + \" must implement TopButtonStateInterface\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container,\r\n                             Bundle savedInstanceState) {\r\n        View view = LayoutInflater.from(mActivity)\r\n                .inflate(getLayoutId(), container, false);\r\n        initView(view, savedInstanceState);\r\n\r\n        //通知activity显示顶部按钮\r\n        topButtonStateInterface.topButtonState();\r\n\r\n        return view;\r\n    }\r\n\r\n    @Override\r\n    public void onActivityCreated(@Nullable Bundle savedInstanceState) {\r\n        super.onActivityCreated(savedInstanceState);\r\n        initData();\r\n    }\r\n\r\n\r\n    /**\r\n     * 该抽象方法就是 onCreateView中需要的layoutID\r\n     *\r\n     * @return\r\n     */\r\n    protected abstract int getLayoutId();\r\n\r\n    /**\r\n     * 该抽象方法就是 初始化view\r\n     *\r\n     * @param view\r\n     * @param savedInstanceState\r\n     */\r\n    protected abstract void initView(View view, Bundle savedInstanceState);\r\n\r\n    /**\r\n     * 执行数据的加载\r\n     */\r\n    protected abstract void initData();\r\n\r\n    /**\r\n     * 顶部主页按钮和返回按钮的回调事件\r\n     * <p>\r\n     * （在activity中通过implements BaseFragment.TopButtonStateInterface使用）\r\n     */\r\n    public interface TopButtonStateInterface {\r\n        void topButtonState();\r\n    }\r\n}\r\n"
        },
        {
          "label": "BaseViewHolder",
          "language": "java",
          "value": "import android.util.SparseArray;\r\nimport android.view.View;\r\nimport android.widget.ImageView;\r\nimport android.widget.TextView;\r\n\r\nimport androidx.recyclerview.widget.RecyclerView;\r\n\r\nimport com.bumptech.glide.Glide;\r\n\r\n/**\r\n * 通用的ViewHolder，与CommonBaseAdapter配套使用\r\n */\r\npublic class BaseViewHolder extends RecyclerView.ViewHolder {\r\n\r\n    private final SparseArray<View> mViews;\r\n\r\n    public BaseViewHolder(View itemView) {\r\n        super(itemView);\r\n        mViews = new SparseArray<>();\r\n    }\r\n\r\n    /**\r\n     * 通过viewId获取控件\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @return\r\n     */\r\n    public <T extends View> T getSubView(int viewId) {\r\n        View view = mViews.get(viewId);\r\n        if (view == null) {\r\n            view = itemView.findViewById(viewId);\r\n            mViews.put(viewId, view);\r\n        }\r\n        return (T) view;\r\n    }\r\n\r\n    /**\r\n     * 点击事件\r\n     *\r\n     * @param viewId   R.id.xxx\r\n     * @param listener\r\n     */\r\n    public void setOnClickListener(int viewId, View.OnClickListener listener) {\r\n        View view = getSubView(viewId);\r\n        view.setOnClickListener(listener);\r\n    }\r\n\r\n    /**\r\n     * 设置TextView内容\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @param text   a string\r\n     */\r\n    public void setText(int viewId, String text) {\r\n        TextView tv = getSubView(viewId);\r\n        if (tv != null) {\r\n            tv.setText(text);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置ImageView背景图片\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @param resId  R.drawable.xxx\r\n     */\r\n    public void setImage(int viewId, int resId) {\r\n        ImageView iv = getSubView(viewId);\r\n        if (iv != null) {\r\n            iv.setBackgroundResource(resId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置ImageView大尺寸图片\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @param resId  R.drawable.xxx\r\n     */\r\n    public void setBigImage(int viewId, int resId) {\r\n        ImageView iv = getSubView(viewId);\r\n        if (iv != null) {\r\n            Glide.with(iv.getContext()).load(resId).into(iv);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置网络资源图片\r\n     *\r\n     * @param viewId R.id.xxx\r\n     * @param resUrl http:\\\\....\\\r\n     */\r\n\tpublic void setNetworkImage(int viewId, String resUrl) {\r\n        ImageView iv = getSubView(viewId);\r\n        if (iv != null) {\r\n//            RequestOptions options = new RequestOptions()\r\n//                    .placeholder(R.drawable.xxx) //加载之前显示的图片\r\n//                    .fallback(R.drawable.xxx) //url为空显示的图片\r\n//                    .error(R.drawable.xxx); //加载失败显示的图片\r\n//            Glide.with(iv.getContext())\r\n//\t\t\t\t\t  .load(resUrl)\r\n//                    .centerInside() //对齐方式\r\n//\t\t\t\t\t  .override(width, height) //图片长宽\r\n//\t\t\t\t\t  .apply(options)\r\n//\t\t\t\t\t  .into(iv);\r\n        }\r\n    }\r\n\r\n}\r\n"
        }
      ],
      "id": "Xg8Bcj-7",
      "createdAt": 1666083554192,
      "updatedAt": 1666083866034
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "5uOcX0Wd",
      "tagsIds": [],
      "description": null,
      "name": "BaseViewHolder",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": ""
        }
      ],
      "id": "442cCGv-",
      "createdAt": 1666083576112,
      "updatedAt": 1666083819036
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "t6KJDGSQ",
      "tagsIds": [],
      "description": "给金额字符串加上单位，中文单位将使用更符合口语的读法，例如：20302￥（2千03百02元 -> 2千3百02元）",
      "name": "NumberToRMB",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "import java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * 给金额字符串加上单位，中文单位将使用更符合口语的读法，\r\n * 例如：20302￥（2千03百02元 -> 2千3百02元）\r\n *       200001000￥（2亿0千0百0十0万1千... -> 2亿01千元）\r\n * <p>\r\n * 调用方式：\r\n * <blockquote>\r\n * List<String> list = new NumberToRMB().getList( String );\r\n * </blockquote>\r\n */\r\npublic class NumberToRMB {\r\n\r\n    private static final String CHINESE_UNIT = \"十亿千百十万千百十元\";\r\n\r\n    /**\r\n     * 返回符合要求的列表\r\n     *\r\n     * @return\r\n     */\r\n    public List<String> getList(String input) {\r\n        List<String> output = new ArrayList<>();\r\n        output.add(\"success\");\r\n        String integerStr, decimalStr;\r\n\r\n        //将整数部分装载到list中\r\n        integerStr = integerAddUnit(input.split(\"\\\\.\")[0]); //十亿01百万1千01十元\r\n        for (int i = 0, len = integerStr.length(); i < len; i++) {\r\n            char value = integerStr.charAt(i);\r\n            switch (value) {\r\n                case '元': //如果是元，得跳过，因为还有小数要装到list中，不能提前放元到list中\r\n                    break;\r\n                case '十':\r\n                    output.add(\"ten\");\r\n                    break;\r\n                case '百':\r\n                    output.add(\"hundred\");\r\n                    break;\r\n                case '千':\r\n                    output.add(\"thousand\");\r\n                    break;\r\n                case '万':\r\n                    output.add(\"ten_thousand\");\r\n                    break;\r\n                case '亿':\r\n                    output.add(\"hundred_million\");\r\n                    break;\r\n                default:\r\n                    output.add(String.valueOf(value));\r\n            }\r\n        }\r\n\r\n        //如果有小数点，将小数部分也装载到list中\r\n        if (input.contains(\".\")) {\r\n            output.add(\"dot\");\r\n            decimalStr = input.split(\"\\\\.\")[1];\r\n            output.add(String.valueOf(decimalStr.charAt(0)));\r\n            if (decimalStr.length() > 1) output.add(String.valueOf(decimalStr.charAt(1)));\r\n        }\r\n\r\n        output.add(\"yuan\");\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * 将小数点前的金额字符串加上单位\r\n     *\r\n     * @param str\r\n     * @return\r\n     */\r\n    private String integerAddUnit(String str) {\r\n        if (str == null || str.length() < 1) return \"0\";\r\n\r\n        //将值都简单的套上单位，例如: 2023000002 => \"2十0亿2千3百0十0万0千0百0十2元\"\r\n        StringBuilder temp = new StringBuilder();\r\n        for (int strIndex = str.length() - 1, unitIndex = CHINESE_UNIT.length() - 1;\r\n             strIndex >= 0;\r\n             unitIndex--, strIndex--) {\r\n            temp.append(CHINESE_UNIT.charAt(unitIndex));\r\n            temp.append(str.charAt(strIndex));\r\n        }\r\n        temp.reverse();\r\n\r\n        //对上一步的结果进行优化，省去不合理的单位，转换成日常读写的样子，例如：“2十0亿2千3百0十0万0千0百0十2元” => \"2十亿2千3百02元\"\r\n        String output = temp.toString();\r\n        for (int strLen = str.length(); strLen >= 0; ) {\r\n            if (strLen >= 9) { //数值大于亿\r\n                output = output.replace(\"0亿\", \"亿\"); // 将类似于 2十0亿 转换成 2十亿\r\n                strLen = 8;\r\n            } else if (strLen >= 5) { //数值大于万且小于亿\r\n                /*\r\n                 * 此处针对类似于：0千0百0十0万、1千0百0十0万、1千1百1十0万 进行优化，优化为 0、1万、1千1百1十万\r\n                 * 其中 0千0百0十0万 情况最为特殊，例如 200'001'000 为 2亿0千0百0十0万1千... 最终化简下来应是\r\n                 * 2亿01千元，如果 0千万 和0十万、0百万一样都替换成 万，则对于上面的例子则会替换成：2亿万1千元，单\r\n                 * 位将产生错误。\r\n                 */\r\n                output = output.replace(\"0万\", \"万\")\r\n                        .replace(\"0十万\", \"万\")\r\n                        .replace(\"0百万\", \"万\")\r\n                        .replace(\"0千万\", \"0\"); //0千万 要替换为 0 .这个很关键\r\n                strLen = 4;\r\n            } else if (strLen >= 2) { //数值十且小于万\r\n                output = output\r\n                        .replaceAll(\"0[十百千万]\", \"0\") //将 0十，0百 等相似情况都转换成 0\r\n                        .replaceAll(\"0+\", \"0\") //在上一步的基础上将 多个连续的零合并，只保留一个\r\n                        .replace(\"0元\", \"元\") //对 1十0元 等相似情况进行转换，转换成 1十元，注意：0元将不会被转换\r\n                        .replaceAll(\"^1十\", \"十\"); //将 1十亿元、1十万元、1十元 转换成 十亿元、十万元、十元\r\n                strLen = -1;\r\n            } else {\r\n                strLen = -1;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n}\r\n"
        }
      ],
      "id": "pALvK4k7",
      "createdAt": 1666084064281,
      "updatedAt": 1666084839782
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "9oVt2TRO",
      "tagsIds": [],
      "description": "音频播放类",
      "name": "VoiceUtil",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "import android.content.Context;\r\nimport android.content.res.AssetFileDescriptor;\r\nimport android.content.res.AssetManager;\r\nimport android.media.MediaPlayer;\r\nimport android.media.PlaybackParams;\r\nimport android.os.Build;\r\n\r\nimport java.io.IOException;\r\nimport java.util.List;\r\nimport java.util.concurrent.CountDownLatch;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n\r\n/**\r\n * 音频播放类\r\n * <p>\r\n * 调用方式：\r\n * <blockquote>\r\n * VoiceUtil.getInstance( Context ).play( List );\r\n * </blockquote>\r\n */\r\npublic class VoiceUtil {\r\n\r\n    private static VoiceUtil mVoiceUtil = null;\r\n    private ExecutorService service; //线程池\r\n    private Context mContext;\r\n    private int count;\r\n\r\n    /**\r\n     * 创建单例\r\n     *\r\n     * @return\r\n     */\r\n    public static synchronized VoiceUtil getInstance(Context context) {\r\n        if (mVoiceUtil == null) {\r\n            mVoiceUtil = new VoiceUtil(context);\r\n        }\r\n        return mVoiceUtil;\r\n    }\r\n\r\n    /**\r\n     * 初始化\r\n     *\r\n     * @param context\r\n     */\r\n    private VoiceUtil(Context context) {\r\n        service = Executors.newCachedThreadPool();\r\n        this.mContext = context;\r\n    }\r\n\r\n    /**\r\n     * 播放前检查\r\n     *\r\n     * @param list\r\n     */\r\n    public void play(final List<String> list) {\r\n        if (service != null) { //如果线程池不等于空\r\n            service.execute(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    start(list); //list: [\"success\", \"1\", \"hundred\", \"yuan\"]\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 开始播放\r\n     *\r\n     * @param list 要播放的语音列表\r\n     */\r\n    private void start(final List<String> list) {\r\n        synchronized (this) {\r\n            final CountDownLatch latch = new CountDownLatch(1); //并发\r\n            MediaPlayer mediaPlayer = new MediaPlayer(); //安卓自带的播放类\r\n\r\n            if (list != null && list.size() > 0) {\r\n                //列表长度和标记位\r\n                final int listLen = list.size();\r\n                count = 0;\r\n                //装载第一个播放项\r\n                AssetManager manager = mContext.getAssets(); //可以读取assets文件中资源的类\r\n                AssetFileDescriptor fd = null;\r\n                try {\r\n                    String path = String.format(\"tts/tts_%s.mp3\", list.get(count));\r\n                    fd = manager.openFd(path);\r\n                    /*\r\n                     * setDataSource参数说明：\r\n                     * 第一个参数：FileDescriptor：您要播放的文件的FileDescriptor\r\n                     * 第二个参数：long：要播放的数据开始的文件的偏移量，以字节为单位\r\n                     * 第三个参数：long：要播放的数据的字节长度\r\n                     */\r\n                    mediaPlayer.setDataSource(fd.getFileDescriptor(), fd.getStartOffset(), fd.getLength());\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                    latch.countDown(); //发出当前线程的完成信号\r\n                } finally {\r\n                    if (fd != null) {\r\n                        try {\r\n                            fd.close(); //关闭文件\r\n                        } catch (IOException e) {\r\n                            e.printStackTrace();\r\n                        }\r\n                    }\r\n                }\r\n                mediaPlayer.prepareAsync(); //通过异步的方式加载\r\n\r\n                //开始播放\r\n                mediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {\r\n                    @Override\r\n                    public void onPrepared(MediaPlayer mediaPlayer) {\r\n                        mediaPlayer.start();\r\n                    }\r\n                });\r\n\r\n                //播放结束的回调\r\n                mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {\r\n                    @Override\r\n                    public void onCompletion(MediaPlayer mediaPlayer) {\r\n                        mediaPlayer.reset(); //重置播放状态\r\n                        count++;\r\n                        //加载下一个音频文件\r\n                        if (count < listLen) {\r\n                            AssetManager nextManager = mContext.getAssets();\r\n                            AssetFileDescriptor nextFd = null;\r\n                            try {\r\n                                String path = String.format(\"tts/tts_%s.mp3\", list.get(count));\r\n                                nextFd = nextManager.openFd(path);\r\n                                mediaPlayer.setDataSource(nextFd.getFileDescriptor(), nextFd.getStartOffset(), nextFd.getLength());\r\n                                mediaPlayer.prepare(); //以同步的方式加载\r\n                                //调整播放速度\r\n                                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) { //只有当前运行的版本大于6.0(VERSION_CODE=M)才运行此部分\r\n                                    PlaybackParams params = new PlaybackParams(); //调整播放参数的类，仅支持6.0及以上\r\n                                    params.setSpeed(1.2f); //播放速度最高支持到8.0f，即8倍速，其他参数还有控制音量\r\n                                    mediaPlayer.setPlaybackParams(params);\r\n                                }\r\n                            } catch (IOException e) {\r\n                                e.printStackTrace();\r\n                                latch.countDown(); //发出当前线程的完成信号\r\n                            } finally {\r\n                                if (nextFd != null) {\r\n                                    try {\r\n                                        nextFd.close(); //关闭文件\r\n                                    } catch (IOException e) {\r\n                                        e.printStackTrace();\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            mediaPlayer.release(); //回收流媒体资源\r\n                            latch.countDown(); //发出当前线程的完成信号\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n                latch.await(); //等待主线程执行完毕，获得开始执行信号\r\n                this.notifyAll();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n"
        }
      ],
      "id": "JNLXEYaE",
      "createdAt": 1666084905919,
      "updatedAt": 1666085264463
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "9oVt2TRO",
      "tagsIds": [],
      "description": "日志收集类，可收集当前应用的所有日志，并写入文件中，如果放在系统级app中，则可收集到所有应用的log。可配合zip工具类实现log文件压缩",
      "name": "LoggingCollect",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "import android.os.Environment;\r\nimport android.os.StatFs;\r\nimport android.util.Log;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Arrays;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\n\r\n/**\r\n * 日志收集类，可收集当前应用的所有日志，并写入文件中，如果放在系统级app中，则可收集到所有应用的log。可配合zip工具类实现\r\n * log文件压缩。\r\n * <p>\r\n * 文件命名格式为：{@code yyyy-MM-dd[HH-mm-ss].txt};日志默认存储路径为：{@code /storage/emulated/0/Logs/}，\r\n * 建议使用{@code context.getFilesDir()} 或 {@code context.getExternalFilesDir()}。\r\n * <p>\r\n * 本类中用到了File类，所以使用的app需要文件读写权限：{@code READ_EXTERNAL_STORAGE} 和\r\n * {@code WRITE_EXTERNAL_STORAGE}，对于android 11+的系统，则需要权限：{@code MANAGE_EXTERNAL_STORAGE}，\r\n * 并在权限控制页面手动允许此权限。\r\n * <p>\r\n * <p>\r\n * 调用方式：\r\n * <blockquote>\r\n * LoggingCollect.INSTANCE.runThread();\r\n * </blockquote>\r\n * <p>\r\n * 如果需要定制参数，可在runThread()方法调用前使用：\r\n * <blockquote>\r\n * initParameter(maxFileSize_MB, logsFolderMaxSize_MB, logsFolder);\r\n * </blockquote>\r\n * 例：\r\n * <blockquote>\r\n * LoggingCollect.INSTANCE.initParameter(1, 100, context.getFileDir());\r\n * </blockquote>\r\n * <p>\r\n * <p>\r\n * 此类中还提供其他文件操作类，可单独进行使用：<p>\r\n * 获取文件夹大小：\r\n * <blockquote>\r\n * LoggingCollect.INSTANCE.getFolderSize_MB(File)\r\n * </blockquote>\r\n * 获取外部存储空间大小：\r\n * <blockquote>\r\n * LoggingCollect.INSTANCE.getStorageAvailableSize(StringPath)\r\n * </blockquote>\r\n * 删除最早创建的文件：\r\n * <blockquote>\r\n * LoggingCollect.INSTANCE.deleteEarliestFileInFolder(File)\r\n * </blockquote>\r\n */\r\npublic enum LoggingCollect {\r\n    INSTANCE; //通过枚举的方式创建单例\r\n    private final static String TAG = \"LoggingCollect\";\r\n    private final static int BUFF_SIZE = 1024; //写入缓冲区的大小（1KB），如果获取到的是系统log，建议调大buff\r\n    private final static int EXTERNAL_STORAGE_SIZE_MB = 1_000; //sd卡存储空间不足1000MB时，删除旧的日志文件，单位MB\r\n\r\n    private int maxFileSize_MB = 4; //单个日志文件大小，单位MB\r\n    private long maxFileSize = maxFileSize_MB * 1024 * 1024; //单个日志文件大小，单位B\r\n    private int logsFolderMaxSize_MB = 100 - maxFileSize_MB; //日志文件夹允许的大小，超过将删除旧文件，单位MB\r\n    //日志默认存储路径：/storage/emulated/0/Logs\r\n    private File logsFolder = new File(Environment.getExternalStorageDirectory() + \"/Logs\");\r\n\r\n    //Thread中使用的变量\r\n    private final SimpleDateFormat mFileSdf = new SimpleDateFormat(\"yyyy-MM-dd[HH-mm-ss]\",\r\n            Locale.getDefault()); //日志文件命名格式：时间.txt\r\n    private Thread t = null;\r\n    private File mLogFile = null;\r\n    private BufferedWriter mWriter;\r\n    private FileWriter mFileWriter;\r\n\r\n\r\n    /**\r\n     * 初始化各项参数，此函数为可选项，如果不调用，会使用默认的值初始化\r\n     *\r\n     * @param maxFileSize_MB       单个log文件存储大小，单位MB\r\n     * @param logsFolderMaxSize_MB log文件夹存储上限，默认100MB\r\n     * @param logsFolder           log存储路径\r\n     */\r\n    public void initParameter(int maxFileSize_MB, int logsFolderMaxSize_MB, File logsFolder) {\r\n        this.maxFileSize_MB = maxFileSize_MB;\r\n        this.maxFileSize = (long) maxFileSize_MB * 1024 * 1024;\r\n        this.logsFolderMaxSize_MB = logsFolderMaxSize_MB;\r\n        this.logsFolder = logsFolder;\r\n    }\r\n\r\n    /**\r\n     * 运行log收集线程\r\n     */\r\n    public void runThread() {\r\n        Log.i(TAG, \"runThread_Configure: maxFileSize_MB= \" + maxFileSize_MB\r\n                + \"; logsFolderMaxSize_MB= \" + logsFolderMaxSize_MB\r\n                + \"; logsFolder= \" + logsFolder.getPath());\r\n\r\n        if (t == null || !t.isAlive()) {\r\n            try {\r\n                Process exec = Runtime.getRuntime().exec(new String[]{\"logcat\", \"-b\", \"all\"});\r\n                final InputStream in = exec.getInputStream();\r\n                final BufferedReader reader = new BufferedReader(new InputStreamReader(in));\r\n\r\n                t = new Thread(() -> {\r\n                    try {\r\n                        synchronized (this) {\r\n                            String line;\r\n                            while (true) {\r\n                                //检查线程是否收到停止信号\r\n                                if (Thread.currentThread().isInterrupted()) {\r\n                                    Log.i(TAG, \"runThread: isInterrupted, break while()\");\r\n                                    break;\r\n                                }\r\n\r\n                                //检查log文件是否存在，不存在就创建新的\r\n                                if (mLogFile == null || !mLogFile.exists()) {\r\n                                    if (!logsFolder.exists()) logsFolder.mkdir();\r\n                                    mLogFile = new File(getNewLogFilePath());\r\n                                    if (!mLogFile.exists()) mLogFile.createNewFile();\r\n                                    mFileWriter = new FileWriter(mLogFile);\r\n                                    mWriter = new BufferedWriter(mFileWriter, BUFF_SIZE); //default buff=1KB\r\n                                }\r\n\r\n                                //写入文件\r\n                                if ((line = reader.readLine()) != null && mWriter != null) {\r\n                                    mWriter.write(line);\r\n                                    mWriter.newLine();\r\n                                    mWriter.flush();\r\n                                }\r\n\r\n                                //如果文件达到指定大小，结束写入，并将mLogFile设为null\r\n                                if (mLogFile.length() >= maxFileSize) {\r\n                                    Log.i(TAG, \"runThread: close file\");\r\n                                    if (mWriter != null) mWriter.close();\r\n                                    if (mFileWriter != null) mFileWriter.close();\r\n                                    mLogFile = null;\r\n                                }\r\n                            }\r\n                        }\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    } finally {\r\n                        try {\r\n                            if (mWriter != null) mWriter.close();\r\n                            if (mFileWriter != null) mFileWriter.close();\r\n                        } catch (IOException e) {\r\n                            e.printStackTrace();\r\n                        }\r\n                        mLogFile = null;\r\n                        Log.i(TAG, \"runThread: thread stop\");\r\n                    }\r\n                });\r\n                Log.d(TAG, \"runThread: start()\");\r\n                t.start();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        } else {\r\n            Log.i(TAG, \"runThread: Thread isAlive, no create\");\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * 停止当前线程\r\n     */\r\n    public void stopThread() {\r\n        if (t == null || !t.isAlive()) {\r\n            Log.i(TAG, \"stopThread: no thread need stop\");\r\n        } else {\r\n            t.interrupt(); //调用停止信号\r\n            if (t.isInterrupted()) {\r\n                t = null;\r\n                Log.i(TAG, \"stopThread: thread is stop\");\r\n            } else {\r\n                Log.e(TAG, \"stopThread: thread stop to fail !\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取以当前时间命名的新文件名路径，如果logs文件夹达到了存储上限，或者存储空间不足，将会先删除旧log文件\r\n     */\r\n    private String getNewLogFilePath() {\r\n        //检测空间是否足够，如果空间不够，先删除旧文件\r\n        while ((getFolderSize_MB(logsFolder) >= logsFolderMaxSize_MB) ||\r\n                (getStorageAvailableSize(logsFolder) <= EXTERNAL_STORAGE_SIZE_MB)) {\r\n            Log.d(TAG, \"Need to delete old log file\");\r\n            deleteEarliestFileInFolder(logsFolder);\r\n        }\r\n        //创建以时间命名的txt文件，返回该文件的路径\r\n        String data = mFileSdf.format(new Date());\r\n        String logFilePath = logsFolder.getPath() + File.separator + data + \".txt\";\r\n        Log.d(TAG, \"getNewLogFilePath: \" + logFilePath);\r\n        return logFilePath;\r\n    }\r\n\r\n\r\n    // =========================== File处理类，可单独使用 ================================ //\r\n\r\n    /**\r\n     * 获取文件夹的大小，单位MB\r\n     *\r\n     * @param folder a folder File\r\n     */\r\n    public long getFolderSize_MB(File folder) {\r\n        long size = 0;\r\n        if (!folder.exists()) return size;\r\n        File[] fileList = folder.listFiles();\r\n        if (fileList == null || fileList.length == 0) return size;\r\n\r\n        for (File f : fileList) {\r\n            //如果是文件，直接加到size上；如果是文件夹，递归里面的文件\r\n            size += f.isDirectory() ? getFolderSize_MB(f) : f.length();\r\n        }\r\n        Log.d(TAG, \"getFolderSize_MB: \" + (size >> 20) + \"MB\");\r\n        return (size >> 20); //等同于：size / 1024 / 1024\r\n    }\r\n\r\n    /**\r\n     * 获取外部存储可用大小\r\n     *\r\n     * @param folder 一个文件路径，通过此路径可判断当前存储区的剩余空间\r\n     */\r\n    public long getStorageAvailableSize(File folder) {\r\n        StatFs fs = new StatFs(folder.getPath());\r\n        long count = fs.getAvailableBlocksLong(); //获取可用块数\r\n        long size = fs.getBlockSizeLong(); //获取单个块的大小\r\n        long availableSize = (count * size) >> 20; //等同于：count * size / 1024 / 1024\r\n        Log.d(TAG, \"getExternalStorageAvailableSize: \" + availableSize + \"MB\");\r\n        return availableSize;\r\n    }\r\n\r\n    /**\r\n     * 删除文件夹中创建时间最早的文件\r\n     *\r\n     * @param folder 要删除的文件夹\r\n     */\r\n    public void deleteEarliestFileInFolder(File folder) {\r\n        if (!folder.isDirectory()) return; //不是一个目录，退出\r\n        File[] files = folder.listFiles();\r\n        if (files == null || files.length == 0) return; //目录中为空，退出\r\n        //对File[]的文件日期进行升序排序，小的在第一个\r\n        Arrays.sort(files, (f1, f2) -> { //a lambda : Arrays.sort(files, new Comparator<File>() {\r\n            long diff = f1.lastModified() - f2.lastModified();\r\n            return diff > 0 ? 1 : (diff == 0 ? 0 : -1);\r\n        });\r\n        //删除最早的文件\r\n        for (File f : files) {\r\n            if (f.isFile()) {\r\n                Log.i(TAG, \"deleteFile: \" + f.getName() + \"; delete result: \" + f.delete());\r\n                return; //删除，并直接退出函数\r\n            }\r\n        }\r\n        Log.i(TAG, \"folder no file, not delete\");\r\n    }\r\n    \r\n    /**\r\n     * 压缩文件，压缩后将删除源文件\r\n     *\r\n     * @param file a file type\r\n     */\r\n    public void zipFile(File file) {\r\n        if (file == null || !file.isFile()) {\r\n            Log.e(TAG, \"zipFile: not a file !!\");\r\n            return;\r\n        }\r\n        String zipPath = file.getPath().replace(FILE_SUFFIX, \".zip\");\r\n        Log.d(TAG, \"zipFile: zip file path= \" + zipPath);\r\n        try {\r\n            ZipUtil.compress(file, new File(zipPath)); //压缩文件\r\n            Log.d(TAG, \"zipFile: delete file= \" + file.delete());\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n"
        }
      ],
      "id": "M6Tu5xjQ",
      "createdAt": 1666084951253,
      "updatedAt": 1666085277063
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "9oVt2TRO",
      "tagsIds": [],
      "description": "FTP操作类，可实现ftp的连接，下载和上传等操作",
      "name": "FtpHelper",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "import android.util.Log;\r\n\r\nimport org.apache.commons.net.ftp.FTPClient;\r\nimport org.apache.commons.net.ftp.FTPClientConfig;\r\nimport org.apache.commons.net.ftp.FTPFile;\r\nimport org.apache.commons.net.ftp.FTPReply;\r\n\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n/**\r\n * FTP操作类，可实现ftp的连接，下载和上传等操作。\r\n * <p>\r\n * <p>\r\n * 类中使用了Apache的Commons Net库。需要将jar包放入libs文件夹，然后在app/build.gradle中增加\r\n * implementation files('libs/CommonsNet的jar包名称') 并sync。\r\n * <p>\r\n * <p>\r\n * 调用方式：\r\n * <blockquote>\r\n * FtpHelper ftp = new FtpHelper(hostName, userName, password);<p>\r\n * ftp.openConnect();\r\n * </blockquote>\r\n * <p>\r\n * <p>\r\n * 下载文件或文件夹：\r\n * <blockquote>\r\n * ftp.downloadFile(remotePath, fileName, localPath);<p>\r\n * ftp.downloadFolder(remotePath, localPath);\r\n * </blockquote>\r\n * <p>\r\n * <p>\r\n * 上传文件或文件夹：\r\n * <blockquote>\r\n * ftp.uploadFile(localFilePath, remotePath);<p>\r\n * ftp.uploadFolder(localFolderPath, remotePath);\r\n * </blockquote>\r\n * <p>\r\n * <p>\r\n * 获取远程的文件列表：\r\n * <blockquote>\r\n * mList = ftp.listFile(remotePath);\r\n * </blockquote>\r\n */\r\npublic class FtpHelper {\r\n    public static final String TAG = \"FtpHelper\";\r\n\r\n    private final String hostName; //服务器地址\r\n    private final int port; //端口，如果不指定，将使用默认值（21）\r\n    private final String userName; //用户名\r\n    private final String password; //密码\r\n    private final FTPClient ftpClient; //FTP连接\r\n\r\n\r\n    /**\r\n     * 构造函数\r\n     *\r\n     * @param hostName 服务器名\r\n     * @param userName 用户名\r\n     * @param password 密码\r\n     */\r\n    public FtpUtil(String hostName, String userName, String password) {\r\n        this.hostName = hostName;\r\n        this.port = 21;\r\n        this.userName = userName;\r\n        this.password = password;\r\n        this.ftpClient = new FTPClient();\r\n    }\r\n\r\n    /**\r\n     * 构造函数\r\n     *\r\n     * @param hostName 服务器名\r\n     * @param port 端口\r\n     * @param userName 用户名\r\n     * @param password 密码\r\n     */\r\n    public FtpUtil(String hostName, int port, String userName, String password) {\r\n        this.hostName = hostName;\r\n        this.port = port;\r\n        this.userName = userName;\r\n        this.password = password;\r\n        this.ftpClient = new FTPClient();\r\n    }\r\n\r\n\r\n    /* ========================================== 连接和关闭 =================================== */\r\n\r\n    /**\r\n     * 打开FTP服务\r\n     *\r\n     * @throws IOException\r\n     */\r\n    public void openConnect() throws IOException {\r\n        int reply; //服务器响应值\r\n\r\n        //连接至服务器\r\n        ftpClient.setControlEncoding(\"UTF-8\"); //中文转码\r\n        ftpClient.connect(hostName, port);\r\n        reply = ftpClient.getReplyCode();\r\n        if (!FTPReply.isPositiveCompletion(reply)) {\r\n            ftpClient.disconnect(); //断开连接\r\n            throw new IOException(\"connect fail: reply=\" + reply);\r\n        }\r\n\r\n        //登录到服务器\r\n        if (userName != null && !userName.equals(\"\")) {\r\n            ftpClient.login(userName, password);\r\n        } else {\r\n            ftpClient.disconnect(); //断开连接\r\n            throw new IOException(\"connect fail: username is null or empty\");\r\n        }\r\n        reply = ftpClient.getReplyCode(); //获取响应值，判断登陆结果\r\n        if (!FTPReply.isPositiveCompletion(reply)) {\r\n            ftpClient.disconnect(); //断开连接\r\n            throw new IOException(\"connect fail: reply=\" + reply);\r\n        } else {\r\n            //获取登录信息\r\n            FTPClientConfig config = new FTPClientConfig(ftpClient.getSystemType().split(\" \")[0]);\r\n            config.setServerLanguageCode(\"zh\");\r\n            ftpClient.configure(config);\r\n            ftpClient.enterLocalPassiveMode(); //使用被动模式设为默认\r\n//           ftpClient.enterLocalActiveMode();\r\n//           ftpClient.enterRemotePassiveMode();\r\n            ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); //二进制文件支持\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 关闭FTP服务\r\n     *\r\n     * @throws IOException\r\n     */\r\n    public void closeConnect() throws IOException {\r\n        if (ftpClient != null) {\r\n            ftpClient.logout(); //登出FTP\r\n            ftpClient.disconnect(); //断开连接\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取ftp连接状态\r\n     *\r\n     * @throws IOException\r\n     */\r\n    public boolean isConnect() {\r\n        return ftpClient.isConnected();\r\n    }\r\n\r\n\r\n    /* ========================================== 下载 =========================================== */\r\n\r\n    /**\r\n     * 下载指定名称的文件\r\n     *\r\n     * @param remotePath FTP目录\r\n     * @param fileName   需要下载的文件名\r\n     * @param localPath  本地存储目录\r\n     * @return Result\r\n     * @throws IOException\r\n     */\r\n    public boolean downloadFile(String remotePath, String fileName, String localPath) throws IOException {\r\n        boolean result = false;\r\n        //在本地创建对应文件夹目录\r\n        File localFolder = new File(localPath);\r\n        if (!localFolder.exists()) Log.d(TAG, \"downloadFile: mkdirs= \" + localFolder.mkdirs());\r\n\r\n        //下载指定文件\r\n        ftpClient.changeWorkingDirectory(remotePath); //更改FTP目录\r\n        FTPFile[] ftpFiles = ftpClient.listFiles(); //得到FTP当前目录下所有文件\r\n        for (FTPFile ftpFile : ftpFiles) {\r\n            if (ftpFile.getName().equals(fileName)) {\r\n                result = downloadSingle(ftpFile, new File(localPath + \"/\" + ftpFile.getName()));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * 下载指定目录\r\n     *\r\n     * @param remotePath FTP目录\r\n     * @param localPath  本地存储目录\r\n     * @return Result 成功下载的文件数量\r\n     * @throws IOException\r\n     */\r\n    public int downloadFolder(String remotePath, String localPath) throws IOException {\r\n        int fileCount = 0; //下载的数量\r\n        //在本地创建对应文件夹目录\r\n        File localFolder = new File(localPath);\r\n        if (!localFolder.exists()) Log.d(TAG, \"downloadFolder: mkdirs= \" + localFolder.mkdirs());\r\n\r\n        //循环遍历\r\n        ftpClient.changeWorkingDirectory(remotePath); //更改FTP目录\r\n        FTPFile[] ftpFiles = ftpClient.listFiles(); //得到FTP当前目录下所有文件\r\n        for (FTPFile ftpFile : ftpFiles) {\r\n            if (!ftpFile.getName().equals(\"..\") && !ftpFile.getName().equals(\".\")) {\r\n                //下载文件夹\r\n                if (ftpFile.isDirectory()) {\r\n                    int count = downloadFolder(remotePath + \"/\" + ftpFile.getName(), localPath);\r\n                    fileCount += count;\r\n                }\r\n                //下载单个文件\r\n                else if (ftpFile.isFile()) {\r\n                    boolean flag = downloadSingle(ftpFile, new File(localPath + \"/\" + ftpFile.getName()));\r\n                    if (flag) fileCount++;\r\n                }\r\n            }\r\n        }\r\n        return fileCount;\r\n    }\r\n\r\n    /**\r\n     * （private属性，外部不可调用）\r\n     * 下载单个文件，此时ftpFile必须在ftp工作目录下\r\n     *\r\n     * @param ftpFile   FTP文件\r\n     * @param localFile 本地目录\r\n     * @return true下载成功, false下载失败\r\n     * @throws IOException\r\n     */\r\n    private boolean downloadSingle(FTPFile ftpFile, File localFile) throws IOException {\r\n        boolean flag;\r\n        OutputStream outputStream = new FileOutputStream(localFile); //创建输出流\r\n        flag = ftpClient.retrieveFile(ftpFile.getName(), outputStream); //下载单个文件\r\n        outputStream.close(); //关闭文件流\r\n        if (flag) {\r\n            Log.d(TAG, \"downloadSingle: success, fileName= \" + ftpFile.getName());\r\n        } else {\r\n            Log.e(TAG, \"downloadSingle: fail, fileName= \" + ftpFile.getName());\r\n        }\r\n        return flag;\r\n    }\r\n\r\n\r\n    /* ========================================== 上传 =========================================== */\r\n\r\n    /**\r\n     * 上传\r\n     *\r\n     * @param localFilePath 需要上传的本地文件路径\r\n     * @param remotePath    FTP目录\r\n     * @return 上传结果\r\n     * @throws IOException\r\n     */\r\n    public boolean uploadFile(String localFilePath, String remotePath) throws IOException {\r\n        boolean flag = false; //返回值\r\n        ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); //二进制文件支持\r\n        ftpClient.setFileTransferMode(FTPClient.STREAM_TRANSFER_MODE); //设置模式\r\n        ftpClient.changeWorkingDirectory(remotePath); //改变FTP目录\r\n        File localFile = new File(localFilePath);\r\n        if (localFile.exists() && localFile.isFile()) {\r\n            flag = uploadingSingle(localFile);\r\n        }\r\n        return flag;\r\n    }\r\n\r\n    /**\r\n     * 上传\r\n     *\r\n     * @param localFolderPath 需要上传的本地文件夹路径\r\n     * @param remotePath      FTP目录\r\n     * @return 上传结果\r\n     * @throws IOException\r\n     */\r\n    public int uploadFolder(String localFolderPath, String remotePath) throws IOException {\r\n        int count = 0;\r\n        ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); //二进制文件支持\r\n        ftpClient.setFileTransferMode(FTPClient.STREAM_TRANSFER_MODE); //设置模式\r\n        ftpClient.changeWorkingDirectory(remotePath); //改变FTP目录\r\n\r\n        File localFolder = new File(localFolderPath);\r\n        if (localFolder.exists() && localFolder.isDirectory()) {\r\n            //在ftp上创建对应的文件夹\r\n            String ftpFolder = remotePath + \"/\" + localFolder.getName();\r\n            ftpClient.makeDirectory(ftpFolder);\r\n            //改变FTP目录\r\n            ftpClient.changeWorkingDirectory(ftpFolder);\r\n            //遍历文件夹\r\n            File[] files = localFolder.listFiles();\r\n            for (File file : files) {\r\n                //如果是文件夹\r\n                if (file.isDirectory()) {\r\n                    int result = uploadFolder(file.getAbsolutePath(), ftpFolder + \"/\" + file.getName());\r\n                    count += result;\r\n                }\r\n                //如果是文件\r\n                else if (file.isFile()) {\r\n                    boolean flag = uploadingSingle(file);\r\n                    if (flag) count++;\r\n                }\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * （private属性，外部不可调用）\r\n     * 上传单个文件，需要先改变ftp的目录\r\n     *\r\n     * @param localFile 本地文件\r\n     * @return true上传成功, false上传失败\r\n     * @throws IOException\r\n     */\r\n    private boolean uploadingSingle(File localFile) throws IOException {\r\n        boolean flag;\r\n        InputStream inputStream = new FileInputStream(localFile); //创建输入流\r\n        flag = ftpClient.storeFile(localFile.getName(), inputStream); //上传单个文件\r\n        inputStream.close(); //关闭文件流\r\n        if (flag) {\r\n            Log.d(TAG, \"uploadingSingle: success, fileName= \" + localFile.getName());\r\n        } else {\r\n            Log.e(TAG, \"uploadingSingle: fail, fileName= \" + localFile.getName());\r\n        }\r\n        return flag;\r\n    }\r\n\r\n\r\n    /* ============================================ 其他功能 ====================================== */\r\n\r\n    /**\r\n     * 列出FTP指定文件夹下所有文件列表\r\n     *\r\n     * @param remotePath ftp文件夹路径\r\n     * @return FTPFile集合\r\n     * @throws IOException\r\n     */\r\n    public List<FTPFile> listFiles(String remotePath) throws IOException {\r\n        List<FTPFile> list = new ArrayList<>();\r\n        ftpClient.changeWorkingDirectory(remotePath); //切换到指定工作目录\r\n        FTPFile[] files = ftpClient.listFiles();\r\n        Collections.addAll(list, files); //遍历并且添加到集合，list.addAll无法直接添加多个元素，添加数组需要使用Arrays.asList()\r\n        return list;\r\n    }\r\n}\r\n"
        }
      ],
      "id": "1Iyb91VS",
      "createdAt": 1666084991975,
      "updatedAt": 1684399421822
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "9oVt2TRO",
      "tagsIds": [],
      "description": "文件压缩类，可压缩文件或文件夹，同时也提供了解压的函数。需要放到线程中运行",
      "name": "ZipUtil",
      "content": [
        {
          "label": "ZipUtil",
          "language": "java",
          "value": "import android.util.Log;\r\n\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.util.zip.ZipEntry;\r\nimport java.util.zip.ZipOutputStream;\r\n\r\n/**\r\n * 文件压缩类，可压缩文件或文件夹，需要放到线程中运行\r\n * <p>\r\n * 调用方式：\r\n * <blockquote>\r\n * ZipUtil().compress(inFile, outFile);\r\n * </blockquote>\r\n */\r\npublic class ZipUtil {\r\n    private static final String TAG = \"ZipUtil\";\r\n    private static final int BUFFER = 4 * 1024; //4KB\r\n\r\n    /**\r\n     * 压缩文件或文件夹\r\n     *\r\n     * @param inFile  指向一个文件或目录的file\r\n     * @param outFile 输出的路径+文件名\r\n     */\r\n    public static void compress(File inFile, File outFile) {\r\n        Log.d(TAG, \"compressPath= \" + inFile.getPath());\r\n        try (\r\n                FileOutputStream outFileStream = new FileOutputStream(outFile);\r\n                ZipOutputStream outZipStream = new ZipOutputStream(outFileStream);\r\n        ) {\r\n            if (inFile.isFile()) {\r\n                FileToZip(inFile, inFile.getName(), outZipStream); //压缩文件\r\n            } else if (inFile.isDirectory()) {\r\n                FolderToZip(inFile, \"\", outZipStream); //压缩目录\r\n            } else {\r\n                Log.e(TAG, \"compress: no file or folder !!\");\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        Log.d(TAG, \"compress: outFile= \" + outFile.getPath());\r\n    }\r\n\r\n\r\n    /**\r\n     * 压缩单个文件（private属性，外部不可调用）\r\n     *\r\n     * @param file           文件\r\n     * @param zipEntryName   保存时的文件名\r\n     * @param zipOutputSteam OutSteam\r\n     * @throws Exception\r\n     */\r\n    private static void FileToZip(File file, String zipEntryName, ZipOutputStream zipOutputSteam) throws Exception {\r\n        ZipEntry zipEntry = new ZipEntry(zipEntryName); //压缩后的文件名\r\n        FileInputStream inputStream = new FileInputStream(file);\r\n        zipOutputSteam.putNextEntry(zipEntry);\r\n        int len;\r\n        byte[] buffer = new byte[BUFFER];\r\n        while ((len = inputStream.read(buffer)) != -1) {\r\n            zipOutputSteam.write(buffer, 0, len);\r\n        }\r\n        inputStream.close();\r\n        zipOutputSteam.closeEntry();\r\n    }\r\n\r\n    /**\r\n     * 压缩目录（private属性，外部不可调用）\r\n     *\r\n     * @param folder         目录\r\n     * @param zipEntryName   保存时的文件名\r\n     * @param zipOutputSteam OutSteam\r\n     * @throws Exception\r\n     */\r\n    private static void FolderToZip(File folder, String zipEntryName, ZipOutputStream zipOutputSteam) throws Exception {\r\n        if (folder.isFile()) {\r\n            FileToZip(folder, zipEntryName, zipOutputSteam);\r\n        } else if (folder.isDirectory()) {\r\n            ZipEntry zipEntry = new ZipEntry(zipEntryName + File.separator);\r\n            zipOutputSteam.putNextEntry(zipEntry);\r\n            zipOutputSteam.closeEntry();\r\n\r\n            String[] fileList = folder.list();\r\n            if (fileList != null && fileList.length > 0) {\r\n                File tempFile;\r\n                String tempString;\r\n                for (String s : fileList) {\r\n                    if (s.endsWith(\".zip\")) continue; //如果是zip文件，则跳过\r\n                    tempFile = new File(folder.getPath() + File.separator + s);\r\n                    tempString = zipEntryName + File.separator + s;\r\n                    FolderToZip(tempFile, tempString, zipOutputSteam);\r\n                }\r\n            }\r\n        } else {\r\n            Log.e(TAG, \"FolderToZip: not a file or folder !!\");\r\n        }\r\n    }\r\n}\r\n"
        },
        {
          "label": "unzipFile",
          "language": "java",
          "value": "/**\n * 将zipFile文件解压到folderPath目录下。\n * <p>\n * 注意：1.解压操作应放到子线程中去运行； 2.不支持含有中文的压缩包\n *\n * @param zipFile    zip文件\n * @param folderPath 解压到的地址\n */\npublic static void unzipFile(File zipFile, String folderPath) throws IOException {\n    Log.i(TAG, \"unzipFile: zipFile=\" + zipFile + \", folderPath=\" + folderPath);\n    if (zipFile == null || folderPath == null) return;\n    if (!zipFile.isFile() || !zipFile.getName().endsWith(\".zip\")) return; //检测zipFile是否合规\n\n    ZipEntry zipEntry;\n    byte[] buffer = new byte[10240];\n    ZipFile zip = new ZipFile(zipFile); //读取一个zip文件\n    Enumeration<?> entries = zip.entries(); //返回zip文件中的枚举\n\n    while (entries.hasMoreElements()) {\n        zipEntry = (ZipEntry) entries.nextElement();\n        Log.d(TAG, \"unzipFile: zipEntry.getName()=\" + zipEntry.getName());\n        File f = new File(folderPath + zipEntry.getName());\n\n        //检测文件的父目录。如果不存在，就创建一个\n        //此处代码的用处有两个：\n        // 1.如果folderPath指向的地址不存在，将会先创建出来。\n        // 2.在某些zip文件上，entries.nextElement()可能会直接返回目录树深处的文件路径，且不再返回其父目录的文件夹名称。\n        //   例如直接返回：aa/bb/1.txt，而不是按照：aa/  aa/bb/  aa/bb/1.txt 的格式返回。\n        //   在这种特殊的情况下如果不判断其父路径是否已创建，后面的创建文件环节将会因父路径不存在而报错。\n        File parentPath = new File(f.getParent() + File.separator);\n        if (!parentPath.exists()) {\n            Log.d(TAG, \"unzipFile: path=\" + parentPath.getPath() + \", mkdirs=\" + parentPath.mkdirs());\n        }\n\n        //创建压缩包中的目录或文件\n        if (zipEntry.isDirectory()) {\n            Log.d(TAG, \"unzipFile: path=\" + f.getPath() + \", mkdir=\" + f.mkdir());\n        } else {\n            Log.i(TAG, \"unzipFile: try unzip file to = \" + f.getPath());\n            InputStream input = new BufferedInputStream(zip.getInputStream(zipEntry)); //来自zip的输入流\n            OutputStream output = new BufferedOutputStream(new FileOutputStream(f)); //指定路径的输出流\n            int readLen;\n            while ((readLen = input.read(buffer)) != -1) {\n                output.write(buffer, 0, readLen);\n            }\n            input.close();\n            output.close();\n        }\n    }\n    zip.close();\n}"
        },
        {
          "label": "other",
          "language": "java",
          "value": "/**\r\n * 获取zip文件解压后的大小（计算文件大小并不耗时，不用放到子线程中）\r\n *\r\n * @param zipFilePath String path\r\n * @return 返回大小以B为单位的数字\r\n */\r\npublic long getZipTrueSize(String zipFilePath) {\r\n    Log.d(TAG, \"getZipTrueSize()\" + \", filePath=\" + zipFilePath);\r\n    long size = 0;\r\n    if (zipFilePath == null || !zipFilePath.endsWith(\".zip\")) {\r\n        Log.e(TAG, \"getZipTrueSize: not a zip file !!\");\r\n        return size; //not zip file path, return\r\n    }\r\n    try (ZipFile zipFile = new ZipFile(zipFilePath)) {\r\n        Enumeration<? extends ZipEntry> en = zipFile.entries();\r\n        while (en.hasMoreElements()) size += en.nextElement().getSize();\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    Log.d(TAG, \"getZipTrueSize: \" + size + \" (Byte)\");\r\n    return size; //Byte大小\r\n}"
        }
      ],
      "id": "INC3bpjL",
      "createdAt": 1666085036032,
      "updatedAt": 1694420924834
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "XVnzjXNQ",
      "tagsIds": [],
      "description": "获取assets文件中的数据",
      "name": "ReadAssetsFile",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "/**\r\n * 获取assets文件中的数据\r\n * <p>\r\n * @param context  getContext()\r\n * @param fileName \"xxx.json\"\r\n * @return String\r\n */\r\npublic static String ReadAssetsFile(Context context, String fileName) {\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    try {\r\n        AssetManager assetManager = context.getAssets();\r\n        BufferedReader bf = new BufferedReader(\r\n                new InputStreamReader(assetManager.open(fileName)));\r\n        String line;\r\n        while ((line = bf.readLine()) != null) {\r\n            stringBuilder.append(line);\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    return stringBuilder.toString();\r\n}\r\n"
        }
      ],
      "id": "iDuK10_X",
      "createdAt": 1666093726140,
      "updatedAt": 1666093766067
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "XVnzjXNQ",
      "tagsIds": [],
      "description": "将状态栏设置成自定义文字和背景",
      "name": "setStatusBarMode",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "/**\r\n * 将状态栏设置成自定义文字和背景\r\n * 此效果只对Android 6.0以上有效果\r\n * <p>\r\n * 调用方式：\r\n * <blockquote>\r\n * setLightMode(getWindow(), R.color.xxx, true);\r\n * </blockquote>\r\n * <p>\r\n * @param win      当前页面窗口\r\n * @param colorId  颜色id\r\n * @param darkText 是否使用深色图标和字体\r\n */\r\npublic static void setStatusBarMode(Window win, int colorId, boolean darkText) {\r\n    // 设置状态栏底色\r\n    win.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\r\n    win.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);\r\n    win.setStatusBarColor(ContextCompat.getColor(win.getContext(), colorId));\r\n\r\n    // 设置状态栏字体是否为黑色\r\n    if (darkText) {\r\n        win.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);\r\n    } else {\r\n        win.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE);\r\n    }\r\n}"
        }
      ],
      "id": "G8OVA6D8",
      "createdAt": 1666093776715,
      "updatedAt": 1666093789485
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "9oVt2TRO",
      "tagsIds": [],
      "description": "防止Toast被多次点击",
      "name": "ToastUtil",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "import android.content.Context;\r\nimport android.widget.Toast;\r\n\r\n/**\r\n * 防止Toast被多次点击\r\n * <p>\r\n * 调用方式：\r\n * <blockquote>\r\n * ToastUtil.showShortToast( Context , String );\r\n * </blockquote>\r\n */\r\npublic class ToastUtil {\r\n\r\n    private static Toast toast;\r\n\r\n    /**\r\n     * 显示短时间的Toast\r\n     *\r\n     * @param context this\r\n     * @param content 消息提醒的内容\r\n     */\r\n    public static void showShortToast(Context context, String content) {\r\n        if (toast == null) {\r\n            toast = Toast.makeText(context, content, Toast.LENGTH_SHORT);\r\n        } else {\r\n            toast.setText(content);\r\n        }\r\n        toast.show();\r\n    }\r\n\r\n    /**\r\n     * 显示长时间的Toast\r\n     *\r\n     * @param context this\r\n     * @param content 消息提醒的内容\r\n     */\r\n    public static void showLongToast(Context context, String content) {\r\n        if (toast == null) {\r\n            toast = Toast.makeText(context, content, Toast.LENGTH_LONG);\r\n        } else {\r\n            toast.setText(content);\r\n        }\r\n        toast.show();\r\n    }\r\n}\r\n"
        }
      ],
      "id": "SXL177w7",
      "createdAt": 1666093811578,
      "updatedAt": 1666094254662
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "XVnzjXNQ",
      "tagsIds": [],
      "description": "在扩展屏中创建一个新页面（双屏异显）",
      "name": "showToMultipleScreen",
      "content": [
        {
          "label": "showToMultipleScreen",
          "language": "java",
          "value": "/**\r\n * 在扩展屏中创建一个新页面（双屏异显）\r\n *\r\n * @param mContext\r\n */\r\npublic void showToMultipleScreen(Context mContext) {\r\n    DisplayManager displayManager = (DisplayManager) getSystemService(Context.DISPLAY_SERVICE);\r\n    Display[] displays = displayManager.getDisplays(); //获取所有屏幕\r\n    Log.d(TAG, \"displays length: \" + displays.length);\r\n    if (displays.length > 1 && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n        MyPresentation myPresentation = new MyPresentation(mContext, displays[1]);\r\n        myPresentation.show();\r\n    }\r\n}"
        },
        {
          "label": "MyPresentation",
          "language": "java",
          "value": "/**\r\n * Presentation类，实际上是一个Dialog，但是增加了双屏异显的支持\r\n */\r\npublic class MyPresentation extends Presentation {\r\n    private final String TAG = this.getClass().getSimpleName();\r\n\r\n    private final Context context;\r\n    private final Display display;\r\n\r\n\r\n    public MyPresentation(Context outerContext, Display display) {\r\n        super(outerContext, display);\r\n        this.context = outerContext;\r\n        this.display = display;\r\n    }\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.layout_presentation);\r\n        Log.d(TAG, \"onCreate: MyPresentation\");\r\n    }\r\n}"
        }
      ],
      "id": "u97hOds-",
      "createdAt": 1666093875917,
      "updatedAt": 1666850108569
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "XVnzjXNQ",
      "tagsIds": [],
      "description": "创建通知，8.0以上的service无法隐式的重启，必须创建通知前台启动",
      "name": "createNotificationChannel",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "/**\r\n * 创建通知，8.0以上的service无法隐式的重启，必须创建通知前台启动\r\n * <p>\r\n * 如果是9.0以上的系统，创建前台服务还需要在{@code AndroidManifest.xml}\r\n * 中增加{@code android.permission.FOREGROUND_SERVICE}权限\r\n */\r\nprivate void createNotificationChannel() {\r\n    String CHANNEL_ID = getPackageName();\r\n    String CHANNEL_NAME = TAG; //任意有标记作用的字符串\r\n\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n        NotificationChannel channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_HIGH);\r\n        /* 其他可用属性：\r\n        channel.enableLights(true);//设置提示灯\r\n        channel.setLightColor(Color.RED);//设置提示灯颜色\r\n        channel.setShowBadge(true);//显示logo\r\n        channel.setDescription(TAG);//设置描述\r\n        channel.setLockscreenVisibility(Notification.VISIBILITY_PUBLIC); //设置锁屏可见 VISIBILITY_PUBLIC=可见\r\n         */\r\n        NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\r\n        manager.createNotificationChannel(channel);\r\n    }\r\n\r\n    Intent intent = new Intent(this, MainActivity.class);\r\n    PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);\r\n\r\n    Notification notification = new NotificationCompat.Builder(this, CHANNEL_ID).\r\n            setContentTitle(TAG)\r\n            .setContentText(TAG + \" is run...\")\r\n            .setWhen(System.currentTimeMillis())\r\n            .setSmallIcon(R.mipmap.ic_launcher) //小图标一定需要设置,否则会报错(如果不设置它启动服务前台化不会报错,但是你会发现这个通知不会启动),如果是普通通知,不设置必然报错\r\n            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))\r\n            .setContentIntent(pendingIntent).build();\r\n    startForeground(1, notification); //服务前台化只能使用startForeground()方法,不能使用 notificationManager.notify(1,notification); 这个只是启动通知使用的,使用这个方法你只需要等待几秒就会发现报错了\r\n}"
        }
      ],
      "id": "t_1CiqS5",
      "createdAt": 1666093924007,
      "updatedAt": 1666093942203
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "1NX5tDl1",
      "tagsIds": [],
      "description": "自定义drawable，使用不同的mipmap图片，设置选中和未选中该显示的图片状态",
      "name": "icon_select.xml",
      "content": [
        {
          "label": "子片段 1",
          "language": "xml",
          "value": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <item android:drawable=\"@mipmap/xxx\" android:state_enabled=\"false\"/>\r\n    <item android:drawable=\"@mipmap/xxx\"/>\r\n</selector>"
        }
      ],
      "id": "isRFaEG8",
      "createdAt": 1666094322751,
      "updatedAt": 1666094464538
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "XVnzjXNQ",
      "tagsIds": [],
      "description": "可直接将当前activity全屏，隐藏状态栏和虚拟返回按钮，必须得上滑才能取消全屏状态，一般用于沉浸阅读的情形。如果是想要类似于全屏看视频的效果，去掉View.SYSTEM_UI_FLAG_IMMERSIVE属性",
      "name": "全屏",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "getWindow().getDecorView().setSystemUiVisibility(\r\n    View.SYSTEM_UI_FLAG_LAYOUT_STABLE //一般用于视频播放的情形\r\n    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION\r\n    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\r\n    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION\r\n    | View.SYSTEM_UI_FLAG_FULLSCREEN\r\n    | View.SYSTEM_UI_FLAG_IMMERSIVE //一般用于沉浸阅读的情形\r\n    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY //用于游戏等严格沉浸的情形,和上一条属性二选一\r\n);"
        }
      ],
      "id": "ihKY3MRG",
      "createdAt": 1666338694612,
      "updatedAt": 1666343118296
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "1NX5tDl1",
      "tagsIds": [],
      "description": "创建悬浮窗",
      "name": "悬浮窗",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "WindowManager windowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);\r\nWindowManager.LayoutParams params = new WindowManager.LayoutParams();\r\nparams.width = 400;\r\nparams.height = 400;\r\nparams.gravity = Gravity.CENTER_VERTICAL | Gravity.END;\r\n//应用退出后仍可显示（需要悬浮窗权限）\r\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n    params.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;\r\n} else {\r\n    params.type = WindowManager.LayoutParams.TYPE_PHONE;\r\n}\r\n//取消焦点捕获\r\nparams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;\r\nView view = LayoutInflater.from(this).inflate(R.layout.view, null);\r\nwindowManager.addView(view, params);"
        }
      ],
      "id": "aDRJlXbs",
      "createdAt": 1666339220484,
      "updatedAt": 1669875862067
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "1NX5tDl1",
      "tagsIds": [],
      "description": "1. 增加了图标和背景；2. 解除了宽度的限制",
      "name": "自定义Toast",
      "content": [
        {
          "label": "Toast",
          "language": "java",
          "value": "Toast toast = new Toast(this);\r\ntoast.setGravity(Gravity.TOP, 0, 100); //设置toast的显示位置\r\ntoast.setDuration(Toast.LENGTH_SHORT); //设置toast显示的时长\r\nView toastView = LayoutInflater.from(this).inflate(R.layout.my_toast_layout, null);\r\nTextView tv = toastView.findViewById(R.id.message);\r\ntv.setText(\"这是一个toast\");\r\ntoast.setView(toastView);\r\ntoast.show();"
        },
        {
          "label": "my_toast_layout",
          "language": "xml",
          "value": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"wrap_content\"\r\n    android:layout_height=\"wrap_content\"\r\n    android:background=\"@drawable/window_background\"\r\n    android:gravity=\"center_vertical\"\r\n    android:orientation=\"horizontal\"\r\n    android:padding=\"8dp\">\r\n\r\n    <ImageView\r\n        android:id=\"@+id/icon\"\r\n        android:layout_width=\"24dp\"\r\n        android:layout_height=\"24dp\"\r\n        android:background=\"@drawable/info\" />\r\n\r\n    <!--注意textView中的layout_weight，和LinearLayout一起达到了解除宽度限制的作用，使用其他方式则无效-->\r\n    <TextView\r\n        android:id=\"@+id/message\"\r\n        android:layout_width=\"0dp\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:layout_marginStart=\"8dp\"\r\n        android:layout_weight=\"1\"\r\n        android:includeFontPadding=\"false\"\r\n        android:maxWidth=\"340dp\"\r\n        android:shadowColor=\"#BB000000\"\r\n        android:shadowRadius=\"2.75\"\r\n        android:textColor=\"#fff\"\r\n        android:textSize=\"16sp\"\r\n        tools:text=\"this a toast message\" />\r\n</LinearLayout>"
        },
        {
          "label": "window_background",
          "language": "xml",
          "value": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" >\r\n    <corners android:radius=\"8dp\"/>\r\n    <solid android:color=\"#4a556a\"/>\r\n</shape>"
        }
      ],
      "id": "tdTXSnHP",
      "createdAt": 1669875846800,
      "updatedAt": 1669876355730
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "XVnzjXNQ",
      "tagsIds": [],
      "description": "将单个文件拷贝到指定目录下",
      "name": "copyFile",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "/**\r\n * 将单个文件复制到指定路径下，新文件使用原来的文件名。如果目的路径下存在相同名称的文件，将会进行覆盖操作。 <p>\r\n * <p>\r\n * 此方法适用于api >= 26，如果想适配26以下，可以将 {@code Files.copy(Path, Path)}\r\n * 替换成 {@code FileUtils.copy(File, File)} <p>\r\n * 如果copy过程中涉及的路径没有访问权限，会报AccessDeniedException <p>\r\n * <p>\r\n * 注意：{@code copyFile(file, destination)} 应放到子线程中去运行。 <p>\r\n *\r\n * @param file        一个存在的文件\r\n * @param destination 拷贝的目的路径，如果路径不存在，会尝试去创建\r\n * @return true：拷贝成功； false：拷贝失败\r\n */\r\n@RequiresApi(api = Build.VERSION_CODES.O)\r\npublic boolean copyFile(File file, String destination) {\r\n    Log.i(TAG, \"copyFile: file=\" + file.getPath() + \", destination=\" + destination);\r\n    if (file == null || !file.isFile()) return false;\r\n\r\n    try {\r\n        //检测目的地址是否存在，没有就创建一个\r\n        File dest = new File(destination);\r\n        if (!dest.exists()) Log.d(TAG, \"copyFile: mkdirs=\" + dest.mkdirs());\r\n\r\n        //file copy to destFile\r\n        File destFile = new File(dest.getPath() + File.pathSeparator + file.getName());\r\n        Log.d(TAG, \"copyFile: destFile=\" + destFile.getPath());\r\n        Files.copy(file.toPath(), destFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\r\n\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n        return false;\r\n    }\r\n    return true;\r\n}"
        }
      ],
      "id": "SyloGKCC",
      "createdAt": 1686114803311,
      "updatedAt": 1691482808848
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "XVnzjXNQ",
      "tagsIds": [],
      "description": "获取json的内容，并将其转成Map",
      "name": "getJsonFileInfo",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "/**\r\n * 获取json的内容，并将其转成Map。<p>\r\n * 注意：如果value的值返回null，存储到Map中时会用\"FF\"做value。<p>\r\n *\r\n * @param jsonFile json文件\r\n * @return 如果json格式转换成功，返回一个Map；如果过程存在错误，则返回null\r\n */\r\npublic Map<String, String> getJsonFileInfo(File jsonFile) {\r\n    if (!jsonFile.exists() || !jsonFile.isFile()) {\r\n        Log.e(TAG, jsonFile.getName() + \"  not exist or not a file!\");\r\n        return null;\r\n    }\r\n    //读取文件内容\r\n    StringBuilder content = new StringBuilder();\r\n    try (InputStream inStream = new FileInputStream(jsonFile);\r\n         InputStreamReader inReader = new InputStreamReader(inStream);\r\n         BufferedReader buffReader = new BufferedReader(inReader)) {\r\n        for (String line; (line = buffReader.readLine()) != null; ) {\r\n            content.append(line).append(\"\\n\");\r\n        }\r\n        Log.i(TAG, \"getJsonFileInfo: json file content= \" + content.toString());\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n        return null; //如果出现异常，则终止\r\n    }\r\n    //文件内容转成json，然后再格式化成map\r\n    Map<String, String> map = new LinkedHashMap<>(); //LinkedHashMap可保证插入的顺序和输出的顺序一致\r\n    try {\r\n        JSONObject json = new JSONObject(content.toString());\r\n        Iterator<String> iterator = json.keys();\r\n        while (iterator.hasNext()) {\r\n            String jsonKey = iterator.next();\r\n            map.put(jsonKey, json.optString(jsonKey, \"FF\")); //如果optString获取不到内容，则用\"FF\"来替代\r\n        }\r\n        Log.i(TAG, \"getJsonFileInfo: map= \" + map.toString());\r\n    } catch (JSONException e) {\r\n        e.printStackTrace();\r\n        return null; //如果出现异常，则终止\r\n    }\r\n    return map;\r\n}"
        }
      ],
      "id": "ftO_8JCj",
      "createdAt": 1691482001922,
      "updatedAt": 1691482063216
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "XVnzjXNQ",
      "tagsIds": [],
      "description": "获得文件的MD5",
      "name": "getMD5",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "/**\r\n * 获得文件的md5值。md5计算的时间与文件大小和设备性能挂钩，如果计算md5的文件较大，请放在线程中执行。\r\n *\r\n * @param f a file\r\n * @return md5 or \"\"\r\n */\r\npublic static String getMD5(File f) {\r\n    BigInteger bi = null;\r\n    try {\r\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n        FileInputStream fis = new FileInputStream(f);\r\n        int len;\r\n        byte[] buffer = new byte[8192];\r\n        while ((len = fis.read(buffer)) != -1) {\r\n            md.update(buffer, 0, len);\r\n        }\r\n        fis.close();\r\n        byte[] b = md.digest();\r\n        bi = new BigInteger(1, b);\r\n    } catch (NoSuchAlgorithmException | IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    if (bi != null)\r\n        return bi.toString(16);\r\n    else\r\n        return \"\";\r\n}"
        }
      ],
      "id": "xt33b0TM",
      "createdAt": 1691482086266,
      "updatedAt": 1691482786239
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "XVnzjXNQ",
      "tagsIds": [],
      "description": "检测是否是快速点击",
      "name": "isFastClick",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "private static long lastClickTime = -1;\r\n/**\r\n * 检测是否是快速点击\r\n *\r\n * @param fastClickTime 快速点击的限制时间，单位：毫秒\r\n * @return true：快速点击\r\n */\r\npublic synchronized static boolean isFastClick(int fastClickTime) {\r\n    long time = SystemClock.elapsedRealtime();\r\n    if (lastClickTime == -1) {\r\n        lastClickTime = time;\r\n        PFLog.d(TAG, \"isFastClick = false\");\r\n        return false;\r\n    }\r\n    if ((time - lastClickTime) < fastClickTime) {\r\n        PFLog.d(TAG, \"isFastClick = true\");\r\n        return true;\r\n    } else {\r\n        lastClickTime = time;\r\n        PFLog.d(TAG, \"isFastClick = false\");\r\n        return false;\r\n    }\r\n}"
        }
      ],
      "id": "PI9cd3uq",
      "createdAt": 1691482219647,
      "updatedAt": 1691482324215
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "XVnzjXNQ",
      "tagsIds": [],
      "description": null,
      "name": "grantFilePermissions",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": ""
        }
      ],
      "id": "lR5_Sw5n",
      "createdAt": 1691482540876,
      "updatedAt": 1691482618218
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "9oVt2TRO",
      "tagsIds": [],
      "description": "文件操作类",
      "name": "FileUtil",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "/**\r\n * 文件操作类\r\n */\r\npublic class FileUtil {\r\n    private final static String TAG = \"FileUtil\";\r\n    \r\n    /**\r\n     * 获得文件的md5值。md5计算的时间与文件大小和设备性能挂钩，如果计算md5的文件较大，请放在线程中执行。\r\n     *\r\n     * @param f a file\r\n     * @return md5 or \"\"\r\n     */\r\n    public static String getMD5(File f) {\r\n        BigInteger bi = null;\r\n        try {\r\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n            FileInputStream fis = new FileInputStream(f);\r\n            int len;\r\n            byte[] buffer = new byte[8192];\r\n            while ((len = fis.read(buffer)) != -1) {\r\n                md.update(buffer, 0, len);\r\n            }\r\n            fis.close();\r\n            byte[] b = md.digest();\r\n            bi = new BigInteger(1, b);\r\n        } catch (NoSuchAlgorithmException | IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        if (bi != null)\r\n            return bi.toString(16);\r\n        else\r\n            return \"\";\r\n    }\r\n    \r\n    /**\r\n     * 将单个文件复制到指定路径下，新文件使用原来的文件名。如果目的路径下存在相同名称的文件，将会进行覆盖操作。 <p>\r\n     * <p>\r\n     * 此方法适用于api >= 26，如果想适配26以下，可以将 {@code Files.copy(Path, Path, options)}\r\n     * 替换成 {@code FileUtils.copy(File, File)} <p>\r\n     * 如果copy过程中涉及的路径没有访问权限，会报AccessDeniedException <p>\r\n     * <p>\r\n     * 注意：{@code copyFile(file, destination)} 应放到子线程中去运行。 <p>\r\n     *\r\n     * @param file        一个存在的文件\r\n     * @param destination 拷贝的目的路径，如果路径不存在，会尝试去创建\r\n     * @return true：拷贝成功； false：拷贝失败\r\n     */\r\n    public static boolean copyFile(File file, String destination) {\r\n        Log.i(TAG, \"copyFile: file=\" + file.getPath() + \", destination=\" + destination);\r\n        if (!file.isFile()) return false;\r\n\r\n        try {\r\n            //检测目的地址是否存在，没有就创建一个\r\n            File dest = new File(destination);\r\n            if (!dest.exists()) Log.d(TAG, \"copyFile: mkdirs=\" + dest.mkdirs());\r\n\r\n            //file copy to destFile\r\n            File destFile = new File(dest.getPath() + File.separator + file.getName());\r\n            Log.d(TAG, \"copyFile: destFile=\" + destFile.getPath());\r\n            Files.copy(file.toPath(), destFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\r\n\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n        Log.i(TAG, \"copyFile: return true\");\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * 给指定的文件或文件夹赋予权限\r\n     *\r\n     * @param f 文件 or 文件夹\r\n     */\r\n    @SuppressLint({\"SetWorldReadable\", \"SetWorldWritable\"})\r\n    public static void grantFilePermissions(File f) {\r\n        if (f.exists()) {\r\n            Log.i(TAG, \"grantFilePermissions: file=\" + f.getName()\r\n                    + \", setReadable=\" + f.setReadable(true, false)\r\n                    + \", setWritable=\" + f.setWritable(true, false)\r\n                    + \", setExecutable=\" + f.setExecutable(true, false));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取文件夹的大小，单位MB\r\n     *\r\n     * @param folder a folder File\r\n     */\r\n    public static long getFolderSize_MB(File folder) {\r\n        long size = 0;\r\n        if (!folder.exists()) return size;\r\n        File[] fileList = folder.listFiles();\r\n        if (fileList == null || fileList.length == 0) return size;\r\n\r\n        for (File f : fileList) {\r\n            //如果是文件，直接加到size上；如果是文件夹，递归里面的文件\r\n            size += f.isDirectory() ? getFolderSize_MB(f) : f.length();\r\n        }\r\n        return (size >> 20); //等同于：size / 1024 / 1024\r\n    }\r\n\r\n    /**\r\n     * 获取外部存储可用大小\r\n     *\r\n     * @param folder 一个文件路径，通过此路径可判断当前存储区的剩余空间\r\n     */\r\n    public static long getStorageAvailableSize(File folder) {\r\n        StatFs fs = new StatFs(folder.getPath());\r\n        long count = fs.getAvailableBlocksLong(); //获取可用块数\r\n        long size = fs.getBlockSizeLong(); //获取单个块的大小\r\n        return (count * size) >> 20; //等同于：count * size / 1024 / 1024;\r\n    }\r\n\r\n    /**\r\n     * 删除文件夹中创建时间最早的文件。由于日志文件名中记录了开机次数，\r\n     * 所以删除文件时会将开机次数最小的一批提取出来，然后从这批中删除时间最早的文件。\r\n     *\r\n     * @param folder 要删除的文件夹\r\n     */\r\n    public static void deleteEarliestFileInFolder(File folder) {\r\n        if (!folder.isDirectory()) {\r\n            Log.w(TAG, \"deleteEarliestFileInFolder: folder not a directory! folder=\" + folder);\r\n            return; //不是目录，退出\r\n        }\r\n\r\n        File[] files = folder.listFiles();\r\n        if (files == null || files.length <= 1) {\r\n            Log.w(TAG, \"deleteEarliestFileInFolder: folder is null or len <= 1! folder=\" + folder);\r\n            return; //只有一个文件或空目录时，不做删除处理\r\n        }\r\n\r\n        //根据根据最小的开机次数进行筛选\r\n        List<File> delFile = new ArrayList<>();\r\n        int min = Integer.MAX_VALUE;\r\n        for (File file : files) {\r\n            //匹配符合要求的zip文件，例262_2023_05_17_13_24_08.zip\r\n            if (Pattern.matches(\"^(\\\\d+_){6}\\\\d+.zip$\", file.getName())) {\r\n                String str_num = file.getName().split(\"_\")[0]; //262_2023_05_17_13_24_08.zip => 262\r\n                int num = Integer.parseInt(str_num);\r\n                if (min > num) {\r\n                    min = num;\r\n                    delFile.clear(); //如果找到新的最小值，则之前存的都将作废，重新开始存\r\n                }\r\n                if (min == num) delFile.add(file); //如果当前值和最小值一致，加入到list中\r\n            }\r\n        }\r\n        if (delFile.size() < 1) {\r\n            Log.w(TAG, \"deleteEarliestFileInFolder: delFile.size() < 1, no delete\");\r\n            return; //没有筛选到文件，不进行删除\r\n        }\r\n\r\n        //对delFile中的文件日期进行升序排序，小的在第一个\r\n        Collections.sort(delFile, (f1, f2) -> {\r\n            long diff = f1.lastModified() - f2.lastModified();\r\n            return diff > 0 ? 1 : (diff == 0 ? 0 : -1);\r\n        });\r\n        Log.i(TAG, \"deleteFile: \" + delFile.get(0).getName()\r\n                + \"; delete result: \" + delFile.get(0).delete()); //删除最早的文件\r\n    }\r\n}"
        }
      ],
      "id": "6mfx9rLY",
      "createdAt": 1691482562736,
      "updatedAt": 1691482762351
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "5uOcX0Wd",
      "tagsIds": [],
      "description": null,
      "name": "Handler",
      "content": [
        {
          "label": "子片段 1",
          "language": "java",
          "value": "public class MyHandler extends Handler {\r\n    private final String TAG = \"MyHandler\";\r\n    private final WeakReference<Activity> mActivity;\r\n\r\n    public MyHandler(Looper looper) {\r\n        super(looper);\r\n    }\r\n\r\n    public MyHandler(Looper looper, Activity activity) {\r\n        super(looper);\r\n        mActivity = new WeakReference<Activity>(activity); //获取弱引用Activity对象\r\n    }\r\n\r\n    @Override\r\n    public void handleMessage(Message msg) {\r\n        super.handleMessage(msg);\r\n        Log.i(TAG, \"MyHandler: \" + msg.what);\r\n        switch (msg.what) {\r\n            //????\r\n            case XXX:\r\n                if (mActivity.get() != null) {\r\n                    //利用弱引用来获取UI控件，不会对回收造成影响\r\n                    mActivity.get().mStateTv.setText(\"state change\");\r\n                }\r\n                break;\r\n\r\n            default:\r\n                Log.w(TAG, \"Unknown message, msg.what = \" + msg.what);\r\n                break;\r\n        }\r\n    }\r\n}"
        }
      ],
      "id": "8rVbNBQO",
      "createdAt": 1695833321541,
      "updatedAt": 1695864455936
    }
  ],
  "tags": [
    {
      "name": "android",
      "id": "wGipkr_Z",
      "createdAt": 1666083463223,
      "updatedAt": 1666083463223
    },
    {
      "name": "基础类",
      "id": "KhvDhBKl",
      "createdAt": 1666083468202,
      "updatedAt": 1666083468202
    },
    {
      "name": "将单个文件拷贝到指定目录下",
      "id": "tncgmYNO",
      "createdAt": 1686115110553,
      "updatedAt": 1686115110553
    },
    {
      "name": "获取json的内容，并将其转成Map",
      "id": "v8NRPVPU",
      "createdAt": 1691482022768,
      "updatedAt": 1691482022768
    }
  ]
}